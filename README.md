
# B+Tree 
this is a project for learning BPlusTree 

## 1 项目背景

`B+树`是一种数据结构，是一个N叉排序树，每个节点通常有多个孩子，一棵`B+树`包含根节点、内部节点和叶子节点。根节点可能是一个叶子节点， 也可能是一个包含两个或两个以上孩子节点的节点。

`B+树`通常用于数据库和操作系统的`文件系统`中。NTFS、NSS、XFS、JFS和BFS等文件系统都在使用`B+树`作为元数据索引。`B+树`的特点是能够保持数据稳定有序， 其插入与修改拥有较稳定的对数时间复杂度。`B+树`元素自底向上插入。

**假设一颗B+树为m阶**，

1. B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。
2. B+树内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。这是与B树最大的不同。
3. m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。
4. 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
5. 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接（双向链表）。
6. 非叶子节点的关键字最少为m/2-1，最多为m-1。叶子节点的关键字最少为m/2，最多为m。

## 2 详细设计（重要）

### 2.1 总体架构

![1](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202309121526037.png)

### 2.2 关键流程

#### 1.插入

![2](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202309121530105.png)

#### 2.删除

![3](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202309121534598.png)

#### 3.查找

![4](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202309121535047.png)

#### 4.序列化和反序列化

**boost介绍**

boost C++库是一组基于C++标准的现代库，可以很方便的集成到C++项目中。Boost C++ 的序列化库允许将 C++ 应用程序中的对象转换为一个字节序列， 此序列可以被保存，并可在将来恢复对象的时候再次加载。

**主要特征**

- 代码可移植性强，仅依赖于标准C++
- 可以直接通过对象的指针保存和恢复数据
- 支持共享指针
- 支持STL容器和其他常用模板的序列化
- 平台可移植性，在一个平台上创建的字节流应在任何其他平台上均可读
- 支持**非侵入性式**序列化，即允许在类外写该类的序列化代码。可以将序列化应用到不能或不想更改的类库中的类而言是必要的
- 可以序列化成多种形式的文档，比如二进制文档，文本文档，xml文档。同时存档接口简单，可以以轻松创建新型存档方式

**实现**

序列化是将对象的状态转换为可以存储或传输的格式的过程。在`Boost.Serialization`中，这是通过类的成员函数 `serialize` 来完成的，该函数负责将对象的成员数据写入输出流（例如文件、内存缓冲区或网络套接字）

**序列化多态指针数据成员**

当基类指针指向一个派生类对象的时候，然后序列化这个指针，那么派生类的信息就会被丢掉

```c++
//注册类类型
//确保反序列化时可以正确地还原对象的类型信息
BOOST_CLASS_EXPORT(CLASS);
```

使用还需注意让Boost知道基类是多态的——确保基类里面有个虚函数；

**为什么能序列化指针**

**指针序列化**：当使用Boost.Serialization来序列化一个指针时，它不仅会将指针的值（即指向的对象的内存地址）序列化到输出流，还会将指针所指向的对象的类型信息也序列化到输出流。这是通过内部的序列化机制完成的，通常涉及调用对象的`serialize`函数。

**反序列化指针：**Boost.Serialization还会在输出流中包含指针所指向的对象的类型信息。这是因为在反序列化时，Boost.Serialization需要知道要创建哪个类型的对象，并将指针指向它。

因此我们可以将包含指针的复杂数据结构序列化和反序列化，而不必担心指针的问题。但我们需要小心处理指针，确保在反序列化后不会出现悬挂指针或内存泄漏等问题。

#### 5 并发控制

 **Search**

仅向下递归，拿到孩子的读锁就释放父亲的读锁。获取 page 的路径从 root 到 leaf 是一条线。到达 leaf 时，仅持有 leaf 的资源。

**Insert/Delete**

先乐观地认为不会发生 split/borrow/merge，对沿途的结点像 Search 操作一样获取和释放 R latch，最终对叶结点上 W latch。

若叶结点 safe，则假设正确，则 Insert/Delete 操作只需叶结点的写锁，可直接完成操作；若叶结点 unsafe，则重新走一遍**基础**的 Latch Crabbing 算法:

```
向下递归，可能会持有多个中间节点的写锁 (记录在队列lockQueue中)。

向上递归。向上递归的路径与向下递归的完全重合，仅是方向相反。因此，向上递归时不需要重复获取锁。在分裂时，新建的 page 由于还未连接到树中，不可能被其他线程访问到，因此也不需要上锁。

在删除操作中乐观锁时先获取要改动叶子节点的最小值，用于悲观锁时判断。若当前中间节点的值和要改动叶子节点的最小值相同，则从当前中间节点开始一直加写锁到最后。
```

`介绍插入、删除、查找、序列化、反序列化、并发控制等关键流程。
使用流程图、数据布局图等辅助说明。`

## 3 代码实现

### 3.1 目录组织

- .vscode:
  - settings.json :vscode编辑器和插件的相关配置
  - c_cpp_properties.json: c++相关的配置
- build:存放编译生成的中间文件和可执行文件
- docs:存放UML，程序流程图，任务报告
- include:存放头文件
- src:存放源代码文件
- test:存放测试相关的代码

### 3.2 安装&测试

项目文件目录下依次执行：

```shell
cmake -G Ninja -S . -B ./build
cmake --build ./build
#正常运行
./build/src/main
#测试
./build/test/t
```

### 3.3 接口

![4](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202309231251572.png)

### 3.4 关键代码

**序列化**

```c++
//侵入式
template <typename T = int>
class LeafNode : public Node<T> { 
    ...
        
//序列化函数设为私有（安全、涉及敏感数据处理）
private:
    
  //授予序列化库对私有变量和函数的访问权限
  friend class boost::serialization::access;
  template <class Archive>
  void serialize(Archive& ar, const unsigned int version) {
      
    //派生类应该包括其基类的序列化
    ar& boost::serialization::base_object<Node<int>>(*this);
    ar& m_RightBro;
    ar& m_LeftBro;
    ar& m_Values;
  }
    ...
}

//非侵入式
namespace boost {
	namespace serialization {
		template<class Archive>
            //非侵入式的一个缺点：需要把数据成员暴露出来(d._tag,d._text)。
		void serialize(Archive & ar, Class & d, const unsigned int version) {
			ar & d._tag;
			ar & d._text;
		}
	} // namespace serialization
} // namespace boost

    //序列化
	BPlusTree<int>* saveTree 
	std::ofstream fout(treeFileName, std::ios::binary | 	std::ios::app);

 	//创建一个序列化对象
	boost::archive::binary_oarchive oa(fout);
	oa << saveTree;
	fout.close();

  //反序列化
  BPlusTree<int>* load;
  std::string openFile;
  std::ifstream ifs(openFile);

  // 创建一个反序列化对象
  boost::archive::binary_iarchive ia(ifs);

  // 反序列化对象
  ia >> load;
  ifs.close();
```

```c++
  bool interResult;
  InterNode<foo>* delInterNode = NULL;

  //使用队列来存储在DelInterNode中删除的节点，待锁释放完后再删除，避免访问已经释放的内存
  std::queue<InterNode<foo>*>* delNodeQueue = new std::queue<InterNode<foo>*>;
  interResult = DelInterNode(pFather, delKey, delNodeQueue);
  ClearLockQueue(&lockQueue);
```



### 3.5 程序分析

**内存泄漏分析**

```
==4997== Memcheck, a memory error detector
==4997== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==4997== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==4997== Command: ./build/src/main
==4997== Parent PID: 4140
==4997== 
==4997== 
==4997== HEAP SUMMARY:
==4997==     in use at exit: 0 bytes in 0 blocks
==4997==   total heap usage: 108 allocs, 108 frees, 92,266 bytes allocated
==4997== 
==4997== All heap blocks were freed -- no leaks are possible
==4997== 
==4997== For lists of detected and suppressed errors, rerun with: -s
==4997== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

**perf(火焰图)**

![1](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202309122024813.png)

**gprof**

![result](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202309131639197.png)



## 4 测试

### 4.1 单元测试

#### 4.1.1 插入测试

**空树插入**

```
插入<1, 1>

 [1  ]
```



**插入不分裂**

```
 [1  ]
 
插入<2, 2> <5, 5> <6, 6>

[1  2  5  6  ]
```



 **插入导致叶子节点分裂**

```
[1  2  5  6  ]

插入<4, 4>

[5  ]
[1  2  4  ][5  6  ]
```



 **插入导致非叶根节点分裂**

```
[5  ]
[1  2  4  ][5  6  ]

插入<8, 8>，<9, 9>，<12, 12>，<3, 3>，<55, 55>，<67, 67>，<13, 13>，<555, 555>，<666, 666>，<454, 454>，<121, 121>，<22, 22>，<33, 33>

[22  ]
[5  9  ][55  555  ]
[1  2  3  4  ][5  6  8  ][9  12  13  ][22  33  ][55  67  121  454  ][555  666  ]
```



**插入导致内部节点分裂**

```
[22  ]
[5  9  ][55  555  ]
[1  2  3  4  ][5  6  8  ][9  12  13  ][22  33  ][55  67  121  454  ][555  666  ]

插入<44, 44>，<37, 37>，<38, 38>，<66, 66>，<68, 68>，<56, 56>

[22  67  ]
[5  9  ][38  55  ][121  555  ]
[1  2  3  4  ][5  6  8  ][9  12  13  ][22  33  37  ][38  44  ][55  56  66  ][67  68  ][121  454  ][555  666  ]
```

#### 4.1.2 删除测试

**删除在路径上的关键字**

```
[22  67  ]
[5  9  ][38  55  ][121  555  ]
[1  2  3  4  ][5  6  8  ][9  12  13  ][22  33  37  ][38  44  ][55  56  66  ][67  68  ][121  454  ][555  666  ]

删除22

[33  67  ]
[5  9  ][38  55  ][121  555  ]
[1  2  3  4  ][5  6  8  ][9  12  13  ][33  37  ][38  44  ][55  56  66  ][67  68  ][121  454  ][555  666  ]
 
```



**删除导致叶子节点和中间节点合并**

```
[33  67  ]
[5  9  ][38  55  ][121  555  ]
[1  2  3  4  ][5  6  8  ][9  12  13  ][33  37  ][38  44  ][55  56  66  ][67  68  ][121  454  ][555  666  ]

删除33

[67  ]
[5  9  37  55  ][121  555  ]
[1  2  3  4  ][5  6  8  ][9  12  13  ][37  38  44  ][55  56  66  ][67  68  ][121  454  ][555  666  ]
```



 **删除不导致叶子节点分裂**

```
[67  ]
[5  9  37  55  ][121  555  ]
[1  2  3  4  ][5  6  8  ][9  12  13  ][37  38  44  ][55  56  66  ][67  68  ][121  454  ][555  666  ]

删除1

[67  ]
[5  9  37  55  ][121  555  ]
[2  3  4  ][5  6  8  ][9  12  13  ][37  38  44  ][55  56  66  ][67  68  ][121  454  ][555  666  ]
```



**删除导致叶子节点合并，中间节点向兄弟借**

```
[67  ]
[5  9  37  55  ][121  555  ]
[2  3  4  ][5  6  8  ][9  12  13  ][37  38  44  ][55  56  66  ][67  68  ][121  454  ][555  666  ]

删除67

[55  ]
[5  9  37  ][68  555  ]
[2  3  4  ][5  6  8  ][9  12  13  ][37  38  44  ][55  56  66  ][68  121  454  ][555  666  ]
```



**删除导致叶子节点向左兄弟借**

```
[55  ]
[5  9  37  ][68  555  ]
[2  3  4  ][5  6  8  ][9  12  13  ][37  38  44  ][55  56  66  ][68  121  454  ][555  666  ]

删除666，68

[55  ]
[5  9  37  ][66  454  ]
[2  3  4  ][5  6  8  ][9  12  13  ][37  38  44  ][55  56  ][66  121  ][454  555  ]
```



**删除导致叶子节点向右兄弟借**

```
[55  ]
[5  9  37  ][66  454  ]
[2  3  4  ][5  6  8  ][9  12  13  ][37  38  44  ][55  56  ][66  121  ][454  555  ]

删除55，5，8

[37  ]
[6  12  ][56  454  ]
[2  3  4  ][6  9  ][12  13  ][37  38  44  ][56  66  121  ][454  555  ]
```



**删除导致根节点删除**

```
[37  ]
[6  12  ][56  454  ]
[2  3  4  ][6  9  ][12  13  ][37  38  44  ][56  66  121  ][454  555  ]
 
删除12

[6  37  56  454  ]
[2  3  4  ][6  9  13  ][37  38  44  ][56  66  121  ][454  555  ]
```



**删除不存在的值**

```
[6  37  56  454  ]
[2  3  4  ][6  9  13  ][37  38  44  ][56  66  121  ][454  555  ]

删除12

[6  37  56  454  ]
[2  3  4  ][6  9  13  ][37  38  44  ][56  66  121  ][454  555  ]
```



**删除至空树**

```
[6  37  56  454  ]
[2  3  4  ][6  9  13  ][37  38  44  ][56  66  121  ][454  555  ]

删除6，37，56，454，9，38，66，4，3，121，44，2，13，555

 [ ]
```

### 4.2 性能测试

**从3度到500度插入10,000,000个数据**

![6](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202309131753895.png)

**与STX B+ Tree比较**

```
---------STX B+ Tree---------
插入花费时间：7.65388
中间节点max：21
叶子节点max:32
清空花费时间：0.07612
---------My B+ Tree---------
节点max:32
插入花费时间：12.9654
清空花费时间：0.164892
```

## 5 总结

总结困难问题的解决思路，以及收获与心得体会。

- 初始化很重要。在随机插入时，使用了vector来帮助打乱和插入，中间节点的分裂总是失败。而不使用vector进行插入就不会出现上述的问题。经过调试发现是指向父节点的指针m_father未初始化，使用vector插入时指向了一片未知的空间。
- 写插入和删除时最开始没有考虑键值的更新，这直接影响到了对树后续的操作
- 序列化string时需要将string作为模板参数的类注册，否则boost库会报错
- 把锁放到队列中的坏处是可能会导致节点先被删除，而锁的对象还存在，此时再从队列中获取锁去解锁就会导致访问未分配的内存，这一点需要注意。







