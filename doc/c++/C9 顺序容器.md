# C9 顺序容器

## 9.1概述

它将单一类型元素聚集起来成为容器，然后根据位置来存储和访问这些元素，这就是顺序容器。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。 

![41](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307061700081.png)

**容器库：**

![42](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307061704229.png)

![43](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307061704695.png)

## 9.2迭代器

**vector和deque提供的额外运算**

![44](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307061707887.png)

![45](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307061707575.png)

**list 容器**的迭代器既不支持算术运算（加法或减法），也不支持关系运算（<=, <, >=, >），它只提供前置和后置的自增、自减运算以及相等 （不等）运算。 

**迭代器范围**

C++ 语言使用一对迭代器标记迭代器范围（iterator range），这两个迭代 器分别指向同一个容器中的两个元素或超出末端的下一位置，通常将它们命名为 first 和 last，或 beg 和 end。

实第二个迭代器从来都不是指向元素范围的最后一个元素，而是指向最后一个元素的下一位置。

此类元素范围称为左闭合区间（left-inclusive interval），其标准表示方式为：

```c++
 // to be read as: includes first and each element up to but not
including last
	 [ first, last ) 
```

![46](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307061722649.png)

![47](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307061723132.png)

## 9.3顺序容器的操作

### 9.3.1容器定义的类型别名

![48](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307061953248.png)

### 9.3.2 顺序容器添加元素

![49](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062043358.png)



**注意：**在容器中添加元素时，系统是将元素值复制到容器里。类似地，使用一段元素初始化新容器时，新容器存放的是原始元素的副本。被复制的原始值与新容器中的元素各不相关，此后，容器内元素值发生变化时，被复制的原值不会受到影响，反之亦然。 

不要存储 end 操作返回的迭代器。添加或删除deque或vector容器内的元素都会导致存储的迭代器失效。 

为了避免存储 end 迭代器，可以在每次做完插入运算后重新计算 end 迭代器值：

```c++
 // safer: recalculate end on each trip whenever the loop adds/erases elements
 while (first != v.end()) {
 // do some processing
 first = v.insert(first, 42); // insert new value
 ++first; // advance first just past the element we added
 }
```

### 9.3.4 关系操作符

所有的容器类型都支持用关系操作符（5.2）来实现两个容器的比较。 比较的容器必须具有相同的容器类型，而且其元素类型也必须相同。

-  如果两个容器具有相同的长度而且所有元素都相等，那么这两个容器就相 等；否则，它们就不相等。

-  如果两个容器的长度不相同，但较短的容器中所有元素都等于较长容器中 对应的元素，则称较短的容器小于另一个容器。

-  如果两个容器都不是对文的初始子序列，则它们的比较结果取决于所比较 的第一个不相等的元素。 

**例子：**

```c++
 /*
 ivec1: 1 3 5 7 9 12
 ivec2: 0 2 4 6 8 10 12
 ivec3: 1 3 9
 ivec4: 1 3 5 7
 ivec5: 1 3 5 7 9 12
 */
 // ivec1 and ivec2 differ at element[0]: ivec1 greater than ivec2
 ivec1 < ivec2 // false
 ivec2 < ivec1 // true
 // ivec1 and ivec3 differ at element[2]: ivec1 less than ivec3
 ivec1 < ivec3 // true
 // all elements equal, but ivec4 has fewer elements, so ivec1 is greater than ivec4
 ivec1 < ivec4 // false
 ivec1 == ivec5 // true; each element equal and same number of elements
 ivec1 == ivec4 // false; ivec4 has fewer elements than ivec1
 ivec1 != ivec4 // true; ivec4 has fewer elements than ivec1
```

C++ 语言只允许两个容器做其元素类型定义的关系运算。 

### 9.3.5. 容器大小的操作

![50](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062107817.png)

![51](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062107438.png)

### 9.3.6 访问元素

![52](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062108068.png)

### 9.3.7 删除元素

![53](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062109213.png)

### 9.3.8 赋值和swap

赋值和 assign 操作使左操作数容器的所有迭代器失效。swap操作则不会使迭代器失效。完成 swap 操作后，尽管被交换的元素已经存放在另一容器中，但迭代器仍然指向相同的元素。

![54](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062112940.png)

## 9.4 再谈string类型

除了已经使用过的操作外（3.2），string 类型还支持大多数顺序容器操作。在某些方面，可将 string 类型视为字符容器。除了一些特殊操作，string 类型提供与 vector 容器相同的操作。string 类型与 vector 容器不同的是，它不支持以栈方式操纵容器：在 string 类型中不能使用 front、back 和 pop_back 操作。 

**构造string的其他方法**

![55](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062121203.png)

**修改 string 对象的其他方法** 

与容器共有的 string 操作 

![56](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062122177.png)

string 类型特有的版本

![57](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062124919.png)

![58](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062124497.png)

**查找与比较**

![59](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062126426.png)

![60](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062127233.png)

![61](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062128515.png)

## 9.5 容器适配器

适配器是一种机制，使得某个事物的行为看起来像另一种事物。
容器、函数、迭代器都有适配器。
容器适配器接受一种已有容器类型，使他看起来向另一种类型。使用容器适配器后不能使用底层容器的操作，只能用适配器的操作管理内存。

默认的 stack 和 queue 都基于 deque 容器实现，而 priority_queue 则 在 vector 容器上实现。在创建适配器时，通过将一个顺序容器指定为适配器的第二个类型实参，可覆盖其关联的基础容器类型。

```c++
 // empty stack implemented on top of vector
 stack< string, vector<string> > str_stk;
 // str_stk2 is implemented on top of vector and holds a copy of svec
 stack<string, vector<string> > str_stk2(svec); 
```

**适配器通用的操作和类型**

![62](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062133995.png)
