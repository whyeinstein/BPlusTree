# C10 泛型算法

## 10.1 概述

标准库提供了一组算法，这些算法大都独立于任何特定容器，但具有通用性（泛型）

**注意：**泛型算法本身从不执行容器操作，只是单独依赖迭代器和迭代器操作实现。算法基于迭代器及其操作实现，而并非基于容器操作。

迭代器令算法不依赖于容器，但依赖于元素类型的操作。泛型算法不会改变底层容器的大小。可能改变容器内元素的值或者位置，但不会增删元素。

使用泛型算法必须包含 algorithm 头文件：

```c++
#include <algorithm> 
```

标准库还定义了一组泛化的算术算法：

```c++
#include <numeric> 
```

## 10.2 算法分类

**只读算法**

```c++
> find
> count
> accumulate
> equal 
```

**写容器元素算法**

- 将新值赋予给序列中元素，此时要确保序列原大小不小于算法要求写入的元素数目。（算法不会改变容器大小）
- 迭代器不会检查写入数据位置大小是否足够大

```c++
> fill(beg,end,val) //将val赋给输入序列每个元素
> fill_n(dest,n,val)//从dest开始n个元素赋值为val
> back_inserter
> copy
> replace
> replace_copy
```

**重排容器元素算法**

```c++
sort(beg,end); //利用<运算符实现排序
unique(beg,end); //重排，不重复元素排在vector开始部分，返回不重复区域之后一个位置的迭代器
```

**例子**

```c++
	string s = "hhdyzwhy";
	cout << s << endl;  //hhdyzwhy
	sort(s.begin(), s.end());
	cout << s << endl; //dhhhwyyz
	auto iter = unique(s.begin(),s.end());
	cout << s << endl;//dhwyzyyz
	s.erase(iter, s.end());
	cout << s << endl; //dhwyz
	return 0;
```

## 10.3迭代器

除容器定义迭代器外，标准库在头文件iterator中还定义了以下迭代器：插入迭代器、流迭代器、反向迭代器和移动迭代器。

```c++
#include <iterator>
```

**插入迭代器**

插入迭代器是一种迭代器适配器，接受一个容器生成迭代器，实现向给定容器添加元素

```c++
it= t; //在it指定位置插入值t
*it,++it,it++ //返回it
```

![63](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062153161.png)

**流迭代器**

虽然iostream类型不是容器，但是标准库还是给它们定义了迭代器。这些迭代器将流当作元素序列进行处理。流迭代器不能递减，只能往前移动。

​					 		**iostream 迭代器的构造函数** 

![64](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062218347.png)

​							**istream_iterator 的操作** 

![65](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062219057.png)

**反向迭代器**

反向迭代器是一种反向遍历容器的迭代器。也就是，从最后一个元素到第一 个元素遍历容器。反向迭代器将自增（和自减）的含义反过来了：对于反向迭代器，++ 运算将访问前一个元素，而 -- 运算则访问下一个元素。除了`forward_list`外，其他容器都支持反向迭代器。

**五种迭代器**

![66](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062229778.png)

## 10.4 泛型算法的结构

**算法的形参模式** 

```c++
 alg (beg, end, other parms);
 alg (beg, end, dest, other parms);
 alg (beg, end, beg2, other parms);
 alg (beg, end, beg2, end2, other parms); 
```

alg 是算法的名字，beg 和 end 指定算法操作的元素范围。我们通常将该范围称为算法的“输入范围”。尽管几乎所有算法都有输入范围，但算法是否使用其他形参取决于它所执行的操作。这里列出了比较常用的其他形参： dest、beg2 和 end2，它们都是迭代器。

## 10.5 容器特有的算法

与其他顺序容器所支持的操作相比，标准库为 list 容器定义了更精细的操作集合， 使它不必只依赖于泛型操作。下表列出了 list 容器特有的操作，其中不包括要求支持双向或更弱的迭代器类型的泛型算法，这类泛型算法无论是用在 list 容器上，还是用在其他容器上，都具有相同的效果。

![67](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307062236886.png)

对于 list 对象，应该优先使用 list 容器特有的成员版本，而不是泛型算法。 

**list 容器特有**的算法与其**泛型算法版本**之间有**两个至关重要的差别**：

- 其中一个差别是 remove 和 unique 的 list 版本修改了其关联的基础容器：真正删除了指定的元素。

- 另一个差别是 list 容器提供的 merge 和 splice 运算会破坏它们的实参。使用 merge 的泛型算法版本时，合并的序列将写入目标迭代器指向的对象， 而它的两个输入序列保持不变。但是，使用 list 容器的 merge 成员函数时， 则会破坏它的实参 list 对象——当实参对象的元素合并到调用 merge 函数的 list 对象时，实参对象的元素被移出并删除。 
