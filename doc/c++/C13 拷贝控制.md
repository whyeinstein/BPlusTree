# C13 拷贝控制

一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值和销毁这些操作在做什么。

- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数

## 13.1 拷贝、赋值与销毁

### 1 拷贝构造函数

拷贝构造函数的**第一个参数是自身类型的引用**，一般会是一个const引用，且**任何额外的参数都有默认值**；拷贝构造几种情况下都会被隐式使用，因此拷贝构造不应该是explicit，需要进行类型转换。

```c++
string dots(10, 'c');    //直接初始化
string s(dots);    //直接初始化
string s2 = dots;    //拷贝初始化
string null_book = "9-999-99999-9" //拷贝初始化
string nines = string(100, '9');    //拷贝初始化
```

拷贝初始化一般用拷贝构造函数和移动构造函数来完成。除用=定义时会发生，下列情况下也会发生拷贝初始化：

- 非引用参数传递
- 非引用返回
- 列表初始化一个数组中的元素或者一个类成员

使用标准库容器时调用***insert***或***push***也会进行拷贝初始化，用***emplace***成员创建的元素进行直接初始化

### 2 拷贝赋值运算符

合成赋值操作符与合成复制构造函数的操作类似。它会执行逐个成员赋值： 右操作数对象的每个成员赋值给左操作数对象的对应成员。除数组之外，每个成 员用所属类型的常规方式进行赋值。对于数组，给每个数组元素赋值。

```c++
// equivalent to the synthesized assignment operator
 Sales_item&
 Sales_item::operator=(const Sales_item &rhs)
 {
  isbn = rhs.isbn; // calls string::operator=
  units_sold = rhs.units_sold; // uses built-in int assignment
  revenue = rhs.revenue; // uses built-in double assignment
  return *this;
 }
```

### 3 析构函数

析构函数没有返回值也不接受参数；在析构函数中，首先执行函数体，然后销毁对象，成员按照初始化顺序的**逆序**销毁。

析构函数的***函数体自身并不直接销毁成员***，而是在析构函数体之后隐含的析构阶段中销毁的。

智能指针是类类型，所以具有析构函数，智能指针成员在析构阶段会被自动销毁

调用析构函数：

- 变量离开其作用域时被销毁；
- 当一个对象被销毁时，其成员被销毁；
- 容器被销毁时，其元素被销毁；
- 动态分配的对象，当对指向它的指针运用delete运算符时被销毁；
- 临时对象，当创建它的完整表达式结束时被销毁；

### 4 阻止拷贝

有的类会定义拷贝控制函数来阻止拷贝，例如iostream，我们可以将拷贝构造函数和拷贝构造运算符定义为**删除的函数**来阻止拷贝；=delete通知编译器，我们不希望定义这些成员。

```c++
Foo(const Foo&) = delete;
Foo &operator=(const Foo&) = delete;
```

与=default不同的是，我们可以指定任何函数为delete的，而只能对编译器合成的默认构造函数或者拷贝控制函数使用default。

如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。本质上如果不可能拷贝、赋值或销毁类的成员时， 类的合成拷贝控制成员就被定义为删除的。


类也可以通过将其拷贝构造函数和拷贝赋值运算符声明为**private**来阻止拷贝。

## 13.2 拷贝控制和资源管理

管理类外资源的类必须定义拷贝控制成员。如P447中所见，这种类需要通过析构函数来释放对象所分配的资源。一旦一个类需要析构函数，那么几乎可确定它也需要一个拷贝构造函数和一个拷贝赋值函数。

明确拷贝语义：可以定义拷贝操作，使类的行为看起来像一个值或者一个指针。

类的行为像一个值，意味着他应该有自己的状态。

### 1 行为像值的类

```c++
class HasPtr {
public:
    HasPtr(const std::string &s = std::string()) : 
            ps(new std::string(s)), i(0) { }
    //对ps指向的每一个string,每个HasPtr对象都有自己的拷贝
    HasPtr(const HasPtr &hp) : 
            ps(new std::string(*hp.ps)), i(hp.i) { }
    HasPtr& operator=(const HasPtr &hp) {
        auto new_p = new std::string(*hp.ps);//拷贝底层string
        delete ps;              //释放旧内存，当发生异常时，能将左侧对象置于以恶搞有意义的状态
        ps = new_p;             //更新指针指向新的分配的string
        i = hp.i;               //从右侧数据拷贝数据到本对象 
        return *this;   //返回本对象
    }
    ~HasPtr() { delete ps;} 
private:
    std::string *ps;
    int i;
};

```

赋值运算符中做了三件事情：
首先，就行了构造函数的工作：new_p的初始化器等价于HasPtr的拷贝构造函数中的ps的初始化器。

接着，与析构函数一样，我们delete当前ps指向的string。

然后，拷贝指向新分配的string指针，以及将i拷贝int值到本对象。

```c++
 HasPtr& operator=(const HasPtr &hp) {
        auto new_p = new std::string(*hp.ps);//拷贝底层string
        delete ps;              //释放旧内
        ps = new_p;             //更新指针指向新的分配的string
        i = hp.i;               //从右侧数据拷贝数据到本对象 
        return *this;   //返回本对象
    }
```

赋值运算符是组合了析构函数和拷贝构造函数的工作。这里的顺序很重要，必须先拷贝，再释放。
一个好的模式是先将右侧对象拷贝到一个临时对象中，当拷贝完成时，销毁左侧运算对象的现有成员就安全了。
一旦左侧对象先被释放或资源被销毁，就只剩下将数据从临时对象拷贝到右侧运算对象的成员中。

### 2 行为像指针的类

对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的 string。我们的类仍然需要自己的析构函数来释放接受string参数的构造函数分配的内存。但是，在本例中，析构函数不能单方面地释放关联的string。只有当最后一个指向string的HasPtr销毁时，才可以释放string。

令一个类展现类似指针的行为的最好方法是使用shared ptr来管理类中的资源。但是，有时我们希望直接管理资源。在这种情况下，使用**引用计数**（reference count)(P402）就很有用了。

**引用计数**的工作方式：

- 除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时， 只有一个对象共享状态，因此将计数器初始化为1

- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。


- 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0,则析构函数释放状态。


- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0,意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。

```c++
class HasPtr {
public:
    //构造分配新的string和新的计数器，将计数器置为1
    HasPtr(const std::string &s = std::string()) : 
            ps(new std::string(s)), i(0)，use(new std::size_t(1)) { }
    //拷贝构造函数，拷贝所有的3个数据成员，并递增计数器
    HasPtr(const HasPtr &p) : 
            ps(p.ps), i(p.i),use(p.use) {++ *use; }
    //
    HasPtr& operator=(const HasPtr &hp) {}
    ~HasPtr() {} 

private:
    std::string *ps;
    int i;
    std::size_t *use;//用来记录有多少个对象共享 *ps 的成员
};

```

## 13.3 拷贝控制示例

我们将定义两个类，这两个类可用于邮件处理应用程序。Message 类和 Folder 类 分别表示电子邮件（或其他）消息和消息所出现的目录，一个给定消息可以出现 在多个目录中。Message 上有 save 和 remove 操作，用于在指定 Folder 中保	存或删除该消息。 

对每个 Message，我们并不是在每个 Folder 中都存放一个副本，而是使每 个 Message 保存一个指针集（set），set 中的指针指向该 Message 所在的 Folder。每个 Folder 也保存着一些指针，指向它所包含的 Message。将要实现 的数据结构如图 13.1 所示。 

![81](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308041720264.png)

创建新的 Message 时，将指定消息的内容但不指定 Folder。调用 save 将 Message 放入一个 Folder。

 复制一个 Message 对象时，将复制原始消息的内容和 Folder 指针集，还 必须给指向源 Message 的每个 Folder 增加一个指向该 Message 的指针。

 将一个 Message 对象赋值给另一个，类似于复制一个 Message：赋值之后， 内容和 Folder 集将是相同的。首先从左边 Message 在赋值之前所处的 Folder 中删除该 Message。原来的 Message 去掉之后，再将右边操作数的内容和 Folders 集复制到左边，还必须在这个 Folder 集中的每个 Folders 中增加一 个指向左边 Message 的指针。

 撤销一个 Message 对象时，必须更新指向该 Message 的每个 Folder。一 旦去掉了 Message，指向该 Message 的指针将失效，所以必须从该 Message 的 Folder 指针集的每个 Folder 中删除这个指针。

 查看这个操作列表，可以看到，析构函数和赋值操作符分担了从保存给定 Message 的 Folder 列表中删除消息的工作。类似地，复制构造函数和赋值操作 符分担将一个 Message 加到给定 Folder 列表的工作。我们将定义一对 private 实用函数完成这些任务。 

```c++
#include<iostream>
#include<vector>
#include<string>
#include<set>
#include<algorithm>
using namespace std;
 
class Folder;
class Message
{
	friend class Folder;
	friend ostream& operator<<(ostream&, const Message&);
	friend void swap(Message&, Message&);
public:
	explicit Message(const string& s = string()) :contents(s), Folders(set<Folder*>()) {}
	Message(const Message&);
	Message& operator=(const Message&);
	~Message();
	// 这两个才是一般情况下使用的成员函数 保存/移除
	void save(Folder&);
	void remove(Folder&);
private:
	string contents;
	set<Folder*> Folders;
	// 拷贝成员，析构函数需要用的工具函数
	void add_to_Folders(const Message&);
	void remove_from_Folders();                // 双向删除
	// used by Folder class to add self to this Message's set of Folder's
	void addFloder(Folder* f) { Folders.insert(f); }
	void removeFolder(Folder* f) { Folders.erase(f); }
};
 
class Folder
{
	friend void swap(Message&, Message&);
	friend Message;
public:
	Folder() = default;
	Folder(const Folder&);
	~Folder();
	Folder& operator=(const Folder&);
	void save(Message& m) { Msgs.insert(&m); m.addFloder(this); }
	void remove(Message& m) { Msgs.erase(&m); m.removeFolder(this); }
private:
	set<Message*> Msgs;
	// 拷贝成员，以及析构函数所需要的工具函数
	void add_to_Messages(const Folder&);
	void remove_from_Msgs();            //双向删除，不同于Message的
	// 
	void addMsg(Message* pm) { Msgs.insert(pm); }
	void removeMsg(Message* pm) { Msgs.erase(pm); }
};
 
void Folder::add_to_Messages(const Folder& f)
{
	for (auto& i : f.Msgs)
		i->addFloder(this);
}
 
void Folder::remove_from_Msgs()
{
	while (!Msgs.empty())
		(*Msgs.begin())->remove(*this);
}
 
Folder::Folder(const Folder& f):Msgs(f.Msgs)
{
	add_to_Messages(f);
}
 
Folder::~Folder()
{
	remove_from_Msgs();
}
 
Folder& Folder::operator=(const Folder& f)
{
	remove_from_Msgs();
	Msgs = f.Msgs;
	add_to_Messages(f);
	return *this;
}
 
 
 
//``````````````````````````````````````````````````````````
void Message::save(Folder& f)
{
	Folders.insert(&f);
	f.addMsg(this);
}
 
void Message::remove(Folder& f)
{
	Folders.erase(&f);
	f.removeMsg(this);
}
 
void Message::add_to_Folders(const Message& m)
{
	for (auto& i : m.Folders)
		i->addMsg(this);  // i是Folder*
}
 
void Message::remove_from_Folders()
{
	for (auto& i : Folders)
		i->removeMsg(this);
	Folders.clear();
}
 
Message::Message(const Message& m):Folders(m.Folders),contents(m.contents)
{
	add_to_Folders(m);
}
 
Message::~Message()
{
	remove_from_Folders();
}
 
Message& Message::operator=(const Message& m)
{
	remove_from_Folders();
	Folders = m.Folders;
	contents = m.contents;
	add_to_Folders(m);
	return *this;
}
 
 
 
ostream& operator<<(ostream& os, const Message& m)
{
	os << m.contents;
	return os;
}
 
void swap(Message& lhs, Message& rhs)
{
	using std::swap;
	cout << "???????????" << endl;
	for (auto& i : lhs.Folders)
		i->removeMsg(&lhs);
	for (auto& i : rhs.Folders)
		i->removeMsg(&rhs);
	swap(lhs.contents, rhs.contents);
	swap(lhs.Folders, rhs.Folders);
	for (auto& i : lhs.Folders)
		i->addMsg(&lhs);
	for (auto& i : rhs.Folders)
		i->addMsg(&rhs);
}
 
 
 
 
int main()
{
	Message m1("111");
	Message m2("222");
	Message m3("333");
	Message m4("444");
	Folder f1;
	Folder f2;
	m1.save(f1);
	m2.save(f1);
	m3.save(f2);
	m4.save(f2);
 
	m1 = m3;
	cout << &m2 << endl;
	cout << &m4 << endl;
	swap(m2, m4);
	cout << &m2 << endl;
	cout << &m4 << endl;
	return 0;
}
```

## 13.4 对象移动

### 1 右值引用

可以通过 && 来获取右值引用，字面意思就是必须要绑定到右值的引用，其有个很重要的性质就是**只能绑定到一个将要销毁的对象**。使用右值引用的代码就可以自由接管所引用的对象的资源/一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。

变量是左值，所以不能将一个右值引用绑定到一个变量上，即使这个变量是右值引用类型也不行；

```c++
int &&rr1 = 42;    //正确：字面值常量是右值
int &&rr2 = rr1;    //错误：表达式rr1是左值
```

头文件utility中定义了move函数，此函数用来告诉编译器：有一个左值，但想像右值一样去处理。调用了move就相当于做出承诺，除了对rr1赋值或销毁它外，将不再使用它；

```c++
int &&rr3 = std::move(rr1);    //正确
```

### 2 移动构造函数和移动赋值运算符

类似于拷贝构造函数，移动构造函数的第一个参数是该类型的一个引用，但这个引用参数是一个右值引用，此外还要确保移动后原对象被销毁。

移动构造函数不分配新内存，它接管原对象的内存。释放左侧运算对象所使用内存，接管给定对象的内存。

移动赋值运算符也和拷贝构造运算符类似，需要右侧运算对象的一个右值，我们不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源，因为左右两边可能指向相同的资源。❤

```
只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。
```

有关定义为删除的问题：

- 与拷贝构造函数不同，有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数，则移动构造函数被定义为删除的。
- 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的 。
- 如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
- 如果有类成员是const的或是引用，则类的移动赋值运算符被定义为删除的。

```
定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的 拷贝操作。否则，这些成员默认被定义为删除的。
```



## 补充

**基本类型(primary categories)**

基本值类型与表达式的两个属性相对应：

1) 有"身份"[has identity]：能够确定某个表达式是否和另一个表达式指涉[refers to]同一个实体，例如，通过比较它们标识[identify]出来的函数或者对象的地址(直接或间接得到的)。
2) 能被移动[can be moved from]：能够被移动构造函数、移动赋值操作符或者其它实现[implement]移动语义[move semantics]的重载函数绑定[bind to]。

根据上面两个属性，我们可以对表达式进行分类：

1) 有"身份"但是不能"被移动"的表达式被称为左值表达式[lvalue expression];
2) 有"身份"同时能"被移动"的表达式被称为x值表达式[xvalue expression];
3) 没有"身份"但是能"被移动"的表达式被称为纯右值表达式[prvalue expression];
4) C++没有既没有"身份"也不能"被移动"的表达式；



**lvalue** 

左值[lvalue,left value]表达式是有"身份"但是不能"被移动"的表达式。这个名字的由来是有历史原因的，它反映了在CPL编程语言中左值是作为赋值运算符的左运算数[left-hand operand]的。

**下面的表达式都是左值表达式：**

1) 在作用域(scope)内的、无论什么类型的变量名或者函数名。比如，std::cin或者std::endl。即使这个变量的类型是右值引用，由它的名字组成的表达式也是个左值表达式。

2) 把左值引用作为返回的函数或者重载操作符。 比如,std::getline(std::cin,str),std::cout << 1, str1 = str2, 或 ++it;

3) a = b, a += b, a %= b, 以及其他所有内置[built-in]的赋值或者复合赋值[compound assignment]表达式。

4) ++a和--a，内置的前置自增[pre-increment]和前置自减[pre-decrement]表达式。\5) *p, 内置的指针取值[indirection]表达式。

6) a[n] 和 p[n], 内置的下标[subscript]索引表达式，【除非[except] ‘a’ 是一个右值数组。(since C++11)】

7) a.m, 对象的取成员变量表达式，除非[except] ‘m’ 是枚举成员或者非静态成员函数，或者 ‘a’ 是右值，以及 ‘m’ 是非引用类型的非静态数据成员。

8) p->m, “对象指针调取内置类型的成员变量” 的表达式，除非[except] ‘m’ 是枚举成员或者非静态成员函数。

9) a.*mp, 对象的成员指针表达式[the pointer to member of object expression]，其中,‘a’必须是左值，‘mp’ 是指向数据成员的指针。

10) a->*mp, 对象指针的成员指针表达式,要求：‘mp’指向的是‘a’的数据成员。

11) a,b, 内置的逗号表达式，要求b必须为左值。 

12) a ? b : c, 对于某些a,b,c的三元条件表达式[ternary conditional expression]。

13) 字符串的字面值类型。如： “Hello World”。

14) 强转为左值引用类型的表达式，如：static_cast<int&>(x);

15) 把右值引用作为返回的函数或者重载操作符。[a function call or an overload operator expression of rvalue reference to function return type]

16) 强转为函数的右值引用类型的表达式，如：static_cast<void (&&) (int)>(x);
    【注：15) 16) 都是从C++11开始使用的】

**左值表达式的属性[properties]:**

1) 拥有glvalue[generalized left value, 广义左值]表达式的所有属性。

2) 可以得到一个左值表达式的地址，例如：&++i和&std::endl是合法的表达式。(假设i是内置类型或者重载的前置自增操作符的返回值是左值引用)

3) 可修改的[modifiable]的左值可以被用作内置的赋值或者复合赋值操作符的左操作数[left-hand operand].

4) 左值可以被用来初始化左值引用。这个操作可以将一个确定的对象关联到一个新的名字。



***\*rvalue【until C++11】 prvalue【since C++11】\****

纯右值[prvalue, pure right value]表达式是没有“身份”，能够“被移动”的表达式。
**下面的表达式都是纯右值表达式：**

1) 除字符串类型外的字面值[literal]，如：42， true, nullptr。

2) 把非引用类型作为返回的函数或者重载操作符。如， str.substr(1,2), str1 + str2, it++。

3) a++ 和 a--，内置的后置自增[post-increment]和后置递减[post-decrement]操作符表达式。

4) a+b, a%b, a&b, a<<b,以及所有其他内置的算术[arithmetic]表达式。

5) a&&b, a||b, ~a,内置的逻辑表达式。

6) a<b, a==b, a>=b,以及所有其他内置的比较表达式。

7) &a, 内置的取址[address-of]表达式。

8) a.m,  对象的取成员变量表达式。其中,‘m’是枚举成员或非静态成员函数，【或者‘a’ 是右值，以及 ‘m’ 是非引用类型的非静态数据成员。(until C++11)】。

9) p->m, 内置的指针取值表达式，其中,m是枚举成员或者非静态成员函数。

10) a.*mp,[ 对象的成员指针](http://blog.csdn.net/yanglingwell/article/details/51169883)表达式[the pointer to member of object expression]。 其中,‘mp’是指向‘a’的成员函数的指针,【或者，‘a’是一个右值，‘mp’是指向数据成员的指针。(until C++11)】。

11) a->*mp, 对象指针的成员指针表达式,其中, ‘mp’指向的是‘a’的成员函数。 

12) a,b, 内置的逗号表达式，其中,b必须为右值。

13) a?b:c, a ? b : c, 对于某些a,b,c的三元条件表达式[ternary conditional expression]。

14) 强转为非引用类型的表达式，比如，static_cast<double>(x), std::string{}, (int)42 。

15) 【lambda 表达式，比如，[](int x){ return x*x; } (since C++11)】。

**纯右值表达式的属性[properties]:**

1) 拥有右值[rvalue]表达式的所有属性。

2) 纯右值表达式不能是多态的[polymorphic]:纯右值表达式标识对象的动态型别总是表达式的型别。[the dynamic type of the object it identifies is always the type of the expression. ]

3) 非类[non-class]的纯右值不能被const或volatile关键字标识[cv-qualified]。

4) 纯右值不能有不完整的型别[type]。除非[except]它是void类型或者用于decltype说明符[specifier]时。



***\*xvalue【since C++11】\****

x值[xvalue, expiring value]表达式是既有“身份”[has identify]，也能够“被移动”[can be moved from]的表达式。
**下面的表达式都是x值表达式：**

1) 把右值引用类型作为返回的函数或者重载操作符。例如, std::move(x);

2) a[n], 内置的下标[subscript]表达式，其中,‘a’是一个右值数组。

3) a.m,  对象的取成员变量表达式。其中,‘a’是一个右值，‘m’ 是非引用类型的非静态数据成员。
4) a.*mp, 对象的成员指针表达式[the pointer to member of object expression]。其中,‘a’是右值，‘mp’是指向数据成员的指针。

5) a?b:c, a ? b : c, 对于某些a,b,c的三元条件表达式[ternary conditional expression]。

6) 强转为“对象的右值引用”表达式，比如，static_cast<char&&>(x)。

**x值表达式的属性[properties]:**

1) 拥有右值[rvalue]表达式的所有属性。

2) 拥有左值[glvalue]表达式的所有属性。
   [注] 类似于纯右值，x值绑定右值引用，但不同的是，x值可能是多态的[polymorphic]，并且非类[non-class]的x值可能被const或volatile关键字标识[cv-qualified]。



***\*混合值类型(maxed gategories)\****

***\*glvalue
\****

广义左值[泛左值, glvalue, generalized left value]表达式是一个左值表达式或者x值表达式。广义表达式“有身份”，它可能能够“被移动”，也可能不能“被移动”。
**广义左值表达式的属性[properties],这些属性同样适用于C++11以前的左值:**

1) 广义左值可能被隐式地[implicitly]转换为纯右值。这是因为有左值到右值，数组到指针，函数到指针的隐式转换。[a glvalue may be implicitly converted to a prvalue with lvalue-to-rvalue, array-to-pointer, or functon-to-pointer implicit conversion.]

2) 广义左值表达式可能是多态的[polymorphic]:表达式标识对象的动态型别不必是总是表达式的静态型别。

3) 只要表达式合法，广义左值能够有不完整类型。



***\*rvalue\****

右值[rvalue, right value]表达式是一个纯右值表达式或x值表达式。右值表达式可能“有身份”，也可能没“有身份”，但能够“被移动”。这个名字的由来是有历史原因的，它反映了在CPL编程语言中左值是作为赋值运算符的右运算数[right-hand operand]的。

**右值值表达式的属性[properties],这些属性同样适用于C++11以前的右值:**

1) 右值不能[may not]被取地址。例如，&int(),  &i++, &std::move(x)都是不合法的。

2) 右值不能[can not]被用作内置的赋值或复合赋值表达式的左操作数[left-hand operand]。

3) 右值可能被用来初始化常左值引用[const lvalue reference]，在这种情况下，这个右值标识对象[the object identified by the rvalue]的生命周期[lifetime]会被延长到这个引用的作用域[scope]的结束。

4) 右值可能被用来初始化常右值引用，在这种情况下，这个右值标识对象[the object identified by the rvalue]的生命周期[lifetime]会被延长到这个引用的作用域[scope]的结束。

5) 作为函数参数[argument]，如果有两个重载函数可用[avaliable]，其中一个把右值引用作为参数[parameter],另一个把常左值引用作为参数，那么右值会绑定[bind to]那个把右值引用作为参数的重载函数。(因此，在拷贝构造函数和移动构造函数都可用[available]的情况下，右值参数会调用[invoke]移动构造函数，拷贝赋值符号和移动赋值符号与之类似。)
   【注：4)、5)从C++11开始使用】