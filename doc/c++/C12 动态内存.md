# C12 动态内存（补充：shared/weak/unque_ptr）

**静态内存**：存储局部static对象，类static对象，以及定义在任何函数之外的对象，使用时创建，程序结束时销毁。

**栈内存**：保存在函数内的非static对象，包括函数形参，函数内局部变量。

**堆内存**：动态分配的内存，在程序运行时分配的对象，动态对象的生存期由程序来控制。

## 12.1 动态内存与智能指针

使用new delete管理内存很容易出现内存泄漏等问题。新标准库使用两种智能指针来管理动态对象。shared_ptr允许多个指针指向同一个对象。unique_ptr“独占”指向对象。weak_ptr作为弱引用指向shared_ptr管理的对象。

##### 12.1.1shared_ptr

![77](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307192338113.png)

```c++
//make shared函数
	//指向一个值为42的int的shared_ptr
	shared_ptr<int> p1 = make_shared<int>(42);
	shared_ptr<string> p2 = make_shared<string>(10, '*');//10个*
	shared_ptr<int> p3 = make_shared<int>();	//值初始化，0
	//使用auto
	auto p4 = make_shared<int>(5);	//5

//shared_ptr拷贝与赋值
	shared_ptr<int> p = make_shared<int>(10);
	auto q(p);
	
//自动释放
	shared_ptr<int> q = make_shared<int>(5);
	shared_ptr<int> p = make_shared<int>(10);
	auto q=p;	//q赋值为p，p的计数器递增，q的计数器递减；q计数器为0，即5被释放。
```

每个shared_ptr都会记录有多少个相同的对象。当计数器的计数为**0**时，就会**自动释放**他所管理的内存空间。

##### 12.1.2 直接管理内存

```c++
//new分配与初始化对象
int* p=new int
int* p=new int(10)；
string* s=new string("woaini");
vector<string>* ps=new vector<string>{"abc","dbg","dad","polkd"};

//auto 
auto x = new auto("abc");		//const char* 类型

//const
const int* a = new const int(10);
const string* b = new const string("abc");
auto c = new const string("5");

//失败
int* p1 = new int;				//分配失败，new抛出bad_alloc
int* p2 = new (nothrow) int;	//分配失败，new返回一个空指针

```

##### 12.1.3 综合使用

使用**普通指针初始化智能指针**： 智能指针的构造函数时explicit的，不支持隐私，所以不能使用拷贝初始化的形式，只能使用**直接初始化**的形式。

```c++
shared_ptr<int> p1=new int(10);		//错误
shared_ptr<int> p1{new int(10)};	//正确，只能使用直接初始化的形式
```

包括在函数的返回值中：必须**显式**的创建shared_ptr< int >，来转换为智能指针。

普通指针与智能指针传递给函数的**注意事项**：

```c++
	void process(shared_ptr<int> ptr)
	{	//这是一个函数体
		//.... 
	}
	//正确方式：
	shared_ptr<int> p(new int(400));
	process(p);
	int i = *p;
	//错误方式：
	int* x(new int(42));			//危险：x不是智能指针
	process(x);						//错误，不能将int* 转换为shared_ptr
	process(shared_ptr<int>(x));	//合法，但是内存会被释放
	int j = *x;						//未定义，x是一个空悬指针
```

注意不要将普通指针和智能指针混用。

##### 12.1.4 智能指针和异常

智能指针在程序结束或者是异常终止，都能将其释放。但是内置指针如果在delete之前被终止，则内存空间不会被释放。

使用自己的释放操作：**制作删除器**：完成对shared_ptr中保存的指针进行释放的操作（相当于析构函数的操作）。

##### 12.1.5 unique_ptr

unique_ptr拥有其对象， 因此**不能普通共享**。

```c++
	unique_ptr<int> p{ new int(100) };
	unique_ptr<int> q{ p };	//不支持拷贝
	unique_ptr<int> c;
	c = p;					//不支持赋值
```

拥有它所指向的对象，某个时刻，只能有**一个**unique_ptr**指向一个给定的对象**。

必须直接初始化：

```c++
unique_ptr<int> p(new int(100));
```

可以借助reset和release完成共享：

- release：释放其指向的对象，将本身置为空，**返回其原来所指的对象**。
- reset(q)：另其**指向q对象**。

```c++
	unique_ptr<int> p{ new int(100) };
	unique_ptr<int> q(p.release());		//转移给q
	unique_ptr<int> c;
	c.reset(q.release());
```

##### 12.1.6 weak_ptr

![78](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307192353502.png)

## 12.2 动态数组

**创建与销毁**

```c++
int* p=new int[10];
delete p;
```

**智能指针和动态数组**

unique_ptr指向一个数组，就不能使用->和 . 运算符（成员访问运算符），但是可以使用[]下标运算符访问元素.

使用shared_ptr的动态数组必须提供自己定义的**删除器**。shared_ptr的动态数组不支持下标，也不支持指针的算术运算。

**allocator类**

提供了将内存分配和对象构造分离开的方法。它分配的内存是原始的，未构造的。

```c++
allocator<string> alloc;			//可以分配string的allocator对象
auto const p = alloc.allocate(n);	//可以分配n个未初始化的string
```

![79](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202307192357389.png)



## 12.3 源码及内部实现机制（补充）

**...**
