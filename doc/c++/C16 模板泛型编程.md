# C16 模板泛型编程

## 16.1 定义模板

### 1 函数模板

- 模板定义以关键字 template 开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个**模板参数的列表**，用小于号和大于号包围起来
- 模板参数表示在类或函数定义中用到的**类型或值**，当使用模板时，显式地或隐式地指定模板参数，将其绑定到模板参数上

**(1)模板类型参数**

- 一般来说，可以将类型参数看作类型说明符，就像内置类型和类类型说明符一样使用，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换
- 类型参数前必须使用关键字 class 或 typename，在模板参数列表中，这两个关键字的含义相同，可以互换使用，但 typename 用来指定模板类型参数更为直观

```c++
template<typename T> T foo(T* p)
{
	T tmp = *p;	//tmp的类型将是指针p指向的类型
	//...
	return tmp;
}
```

**(2)非类型模板参数**

- 除了定义类型参数，也可以在模板中定义非类型参数，一个非类型参数表示一个值而非一个类型，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数
- 当一个模板被实例化时，非类型参数被一个用户提供地或编译器推断出的值代替，这个值必须是常量表达式，从而允许编译器在编译时实例化模板

```c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char（&p2）[M])
{
	return strcmp(p1, p2);
}

//当调用这个版本的 compare 时
compare("hi", "mom");
//会实例化出如下版本
int compare(const char (&p1)[3], const char（&p2)[4]);
```

- 一个非类型参数可以是一个**整型**，或者是一个指向对象或函数类型的**指针或（左值）引用**，绑定到**非类型整型参数**的实参必须是一个常量表达式，绑定到指针或引用**非类型参数**必须具有静态的生存期

**(3)inline 和 constexpr 的函数模板**

- 函数模板可以声明为 inline 或 constexpr 的，如同非模板函数一样，inline 或 constexpr 说明符**放在模板参数列表之后，返回类型之前**

```c++
//正确
template <typename T> inline T min(const T&, const T&);
//错误：inline说明符的位置不正确
inline template<typename T> T min(const T&, const T&);
```

**(4)模板编译**

- 当编译器遇到一个模板定义时，它并不生成代码，只有当实例化出模板的一个特定版本时，编译器才会生成代码
- 但模板则不同，为了生成一个实例化版本，编译器必须掌握函数模板或类模板成员函数的定义，因此与非模板代码不同，模板的头文件通常既包括声明也包括定义，即函数模板和类模板成员函数的定义通常放在头文件中



### 2 类模板（❤...）

- 与函数模板不同，编译器不能为类模板推断模板参数类型

**定义类模板**

```c++
template <typename T> class Blob {
public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type;
    // 构造函数
    Blob();
    Blob(std::initializer_list<T> il);
    // Blob中的元素数目
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }
    // 添加和删除元素
    void push_back(const T &t) { data->push_back(t); }
    // 移动版本
    void push_back(T &&t) { data->push_back(std::move(t)); }
    void pop_back();
    // 元素访问
    T& back();
    T& operator[](size_type i);
private:
    // Q: 为什么使用智能指针?
    std::shared_ptr<std::vector<T>> data;
    // 若data[i]无效，则抛出msg
    void check(size_type i, const std::string &msg) const;
};
```

当使用一个类模板时，我们必须提供额外信息，即显式模板实参`explicit template argument`，编译器使用这些模板实参来实例化出特定的类。

```c++
Bolb<int> ia;
Blob<int> ia2 = {0,1,2,3,4};
```

**在模板作用域内引用模板类型**

我们的`data`成员使用了两个模板：`vector`和`shared_ptr`，我们将其定义为：

```c++
std::shared_ptr<std::vector<T>> data;
```

实例化一个特定类型的Blob如Blob<string>,data会成为shared_ptr<vector<string>>

**类模板的成员函数**❤

`Blob`的成员函数应该这么定义：

```c++
template <typename T>
ret-type Bolb<T>::member-name(param-list)
```

`check`和元素访问成员

```c++
template <typename T>
void Bolb<T>::check(size_type i, const std::string &msg) const
{
    if (i >= data->size())
        throw std::out_of_range(msg);
}
```

**Blob构造函数**

```c++
template <typename T>
// 构造函数分配一个空vector, 并将指向vector的指针保存在data中
Bolb<T>::Blob() : data(std::make_shared<std::vector<T>>()) { }
 
// 接受一个initializer_list参数的构造函数将其类型参数为T作为initializer_list参数的元素类型
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il) : data(std::make_shared<std::vector<T>>(il)) { }
 
// 使用方法: 在这条语句中构造函数的参数类型为initializer_list<string>,列表中每个字符串字面常量会被隐式地转换为一个string
Blob<string> articles = {"a", "an", "the"};
```

**类模板和友元**❤

1.  若一个类模板包含一个非模板友元，则该友元可以访问所有类模板实例。
2.  若一个非模板类包含一个模板友元，则所有友元实例可以访问该类。
3.  若一个类模板和友元模板有相同的类型参数，则类与友元为 一对一 的友好关系。
4.  若一个类模板与友元模板有不同的类型参数，则类的每一个实例授权给所有友元模板实例。

```c++
template<typename> class BlobPtr;	 前置声明，在Blob中声明为友元所需要的

template<typename> calss Blob;		 前置声明，声明 operator== 函数所必要的

template<typename T> 				 前置声明，在Blob中声明为友元所必要的操作
	bool operator==(const Blob<T>&, const Blob<T>);

template<typename T> class Blob
{
	friend class BlobPtr<T>;		 引用类模板的特定实例
	friend bool operator==<T>(const Blob&, const Blob&);	引用函数模板的特定实例
	// ...其他成员省略... //
};
```

声明友元本身并不需要友元的前置声明，但如果友元是一个模板 且 在声明友元时引用了他的某个实例，就必须前置声明了。
上面代码中，为了在Blob中引用特定实例，我们必须先声明类模板BlobPtr和函数模板operator==，由于operator==中含有Blob的实例，所以还要在operator==声明前，先声明Blob类模板。

然后再看Blob的友元声明，BlobPtr 和 operator==都使用Blob的模板形参引用各自的特定实例，所以友元关系被限定在用相同类型实例化的Blob和operator==。

普通类 与 友元模板有一对一 和 一对多两种情况：

```c++
//模板类 和 普通友元
template<typename T> class C2
{
	template<typename X> friend class Pal2;		Pal2的所有实例都是C2所有实例的友元，多对多
	friend class Pal3;		Pal3是所有 C2 实例的友元，多对一
};
```

```c++
//模板自己的类型参数成为友元
template<typename T> class Bar
{
	friend T;	把访问权限授予用来实例化Bar的类型
};
```

**模板 与 `typedef` 、`using`**

定义一个`typedef`引用**实例化的类**。

```c++
typedef Blob<string> StrBlob;
```

使用`StrBlob`就相当于使用一个用`string`实例化的`Blob`。
由于模板不是一个类型，所以不能定义一个`typedef`引用模板。

但是，新标准允许用`using`为类模板定义类型别名。

**using**

```c++
template<typename T> using twin = pair<T, T>;
twin<double> t1;	//t1 是一个 pair<double, double>

template<typename T, typename X> using twin2 = pair<T, X>;
twin2<double, int> t2;		//这样就跟直接使用 pair 没啥区别了

template<typename T> using twin3 = pair<double, T>;
twin3<int> t3;		//也可以这样，自己固定一个类型，t3 是一个 pair<double, int>
					//用户可以指定second成员的类型，但不能指定first成员的类型
```

**类模板的`stiatic`成员**

**每个**类模板的**实例** 都有**各自的** `static`成员实例。
与普通类的`static`数据成员一样，类模板的`static`数据成员仍要在类外初始化。不同的是，类模板的`static`数据成员应该定义为模板：

```c++
template<typename T> class Foo
{
public:
	static int count() { return cnt; }
private:
	static int cnt;
};
template<typename T> int Foo<T>::cnt = 10;		//这里就不用加 static 了
```

注意上面`cnt`的初始化格式。与类外定义类模板的成员函数格式类似，**模板参数列表**起手。别忘记加上类模板的**作用域**。

和其他模板成员函数一样，`static`成员函数也是只有在使用到的时候，才会实例化。

### 3 模板参数

**模板参数 和 作用域**

一个模板参数名的可用范围在其**声明之后**，直到模板声明或定义**结束之前**在**模板作用域内不能重用**模板参数名

**使用类的类型成员**

```c++
template<typename T> class X
{
	T::size_type * p;		//这表示的是 p 是一个指针变量呢？
};								//还是 T 里名为 size_type 的static数据成员与变量 p 相乘呢？
```

**默认**情况下，C++语言认为通过作用域运算符访问的名字**不是类型**。如果希望使用模板参数的类型成员，必须**显式告诉**编译器改名字是一个类型。使用**关键字`typename`实现**这一点：

```c++
template<typename T> typename T::value_type func(const T& t)
{
	return typename T::value_type();		默认初始化一个value_type类型的变量，并返回
}
```

**默认模板实参**

C++新标准中，可以为函数模板和类模板提供默认模板实参，以前只能为类模板提供默认模板实参。

**函数模板**的默认模板实参❤

```c++
template<typename T, typename F = less<T>> int compare(const T& v1, const T& v2, F f = F())
{
	if (f(v1, v2)) return 1;
	if (f(v1, v1)) return -1;
	return 0;
}
```

**类模板**的默认模板实参

```c++
template<typename T = int> class Numbers
{
private:
	T value;
};
Numbers<> num1;			//空<>，表示使用默认类型，int 类型的 Numbers
Numbers<double> num2;	//double 类型的 Numbers
```

### 4 成员模板

任何一个类可以包含本身是模板的成员函数，这叫做 成员模板。**成员模板不能是虚函数。**

**普通类和成员模板**

```c++
class DebugDelete
{
public:
	DebugDelete(ostream& s = cerr) : os(s) { }
	template<typename T> void operator()(T* p)
	{
		cerr << "deleteing unique_ptr" << endl;
		delete p;
	}
private:
	ostream& os;
};

double* p1 = new double(3.14);
DebugDelete d;
d(p1);		//销毁 p1 指向的动态内存

unique_ptr<int, DebugDelete> p2(new int, DebugDelete());	
//这是 unique_ptr 的一个构造函数，接受自定义的删除器对象
//这里是分配了一个临时的匿名int，然后立即销毁

```

**类模板和成员模板**

对于类模板及其成员模板，他们各自有自己的、独立的模板参数。

```c++
template<typename T> class Blob
{
public:
	template<typename Iter> Blob(Iter begin, Iter end);
	// ...
};
```

与类模板的普通成员函数不同，成员模板是函数模板，当在**类外定义**一个**成员模板**时，必须**同时** **为类模板和成员模板提供参模板数列表**。类模板的参数列表在前，成员模板的参数列表在后。

```c++
template<typename T> template<typename Iter> Blob<T>::Blob(Iter begin, Iter end)
{
	// ......
}
```

上面的定义中，类模板有一个模板类型参数，命名为`T`。而成员自身是一个函数模板，有一个名为`Iter`的类型参数。

**成员模板的实例化**

成员模板实例化时仍然遵循普通函数模板的规则，只不过是要和类模板的实例化结合起来

```c++
int arr[] = { 1, 2, 3, 4, 5 };
vector<double> v = { 1.1, 2.2, 3.3, 4.4, 5.5 };
list<const char*> li = { "aa", "ww", "ee", "xx", "dd" };

Blob<int> b1( begin(arr), end(arr) );
Blob<double> b2( v.begin(), v.end() );
Blob<string> b3( li.begin(), li.end() );
```

### 5 控制实例化

当模板被使用时才会实例化，这会产生一个问题：当两个或多个独立变异的源文件使用了相同的模板，并提供了相同的模板参数时，相同的实例就出现在了多个对象文件中。这样的开销在大系统中是经受不起的。通过**显式实例化**来避免这种开销。

- 显式实例化：一个声明，为所有模板参数提供了显式实参；用来指导实例化过程；如果声明是 extern 的，模板将不会实例化，否则模板将利用指定的实参进行实例化；对于每个 extern 模板声明，在程序中某处必须有一个非 extern 的显式实例化

```c++
extern templete declaration;	//实例化声明
templete declaration;			//实例化定义
```

- 由于编译器在使用一个模板时自动对其实例化，因此 extern 声明必须出现在任何使用此实例化版本的代码之前
- 对于实例化声明，在程序中某个位置必须有其显式的实例化定义
- 实例化定义会实例化所有成员。一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数
- 因此，在一个类模板的实例化定义中，所有类型必须能用于模板的所有成员函数

## 16.2 模板实参推断

从函数实参到模版实参的过程被称为模版实参推断，在这个过程中，可能会发生类型转换。

### 1 类型转换与模板实参推断

在模版推断的过程中，编译器根据函数调用的实参类型来寻找模版实参，用这些模版实参生成的函数版本与给定的函数调用匹配。
  只有两种情况会发生类型转换：

- 非const对象的引用或者指针到const对象的引用或者指针（const到非const是不合法的）（顶层const会被忽略）。
- 若函数参数不是引用的类型，则可以进行函数或者数组的指针类型转换，我们可以用函数实参或者数组实参转化为对应指针。

注意:

1. 将实参传递给代模板类型的参数时，能够自动类型转换的只有const转换及数组或函数到指针的转换。如果想要传递不同的参数，则我们必须自己定义那种不同的模板类型。
2. 如果函数模板的参数不是模板则可以正常进行转换。
3. 算术类型转换不能支持模版函数的类型转换，若我们想要两个不同类型的参数，定义两个不同的模版参数即可。

### 2 函数模板显式实参

在某些情况下，编译器无法推断出模板实参的类型。在其他一些情况下，我们希望允许用户控制模板实例化。通常有两个原因：

- 模版实参作为函数的返回类型，传入的函数实参不能推断出函数的返回类型。
- 我们希望可以参数指定类型，进行类型转换。

    显式模版实参，位于函数名后，参数列表之前，注意其函数模版实参是按从左至右顺序进行匹配的，之后尾部的参数可以忽略（忽略的前提是可以通过传入的实参进行推断），所以不要将最后的参数作为返回类型，否则需要将所有的模版实参进行显式的初始化：

```c++
/**************
*函数模板显示实参。
***************/
template <typename T1, typename T2, typename T3>
T1 sum(T2 t2, T3 t3)
{
	T1 p = t2 + t3;
	return p;
}

long lng = 1000000;
auto val2 = sum<long long>(1,lng);//指定显式模板实参。
cout << val2 << endl;
```

### 3 尾置返回类型与类型转换

  一些情况下，要求显式指定模板实参会给用户添加额外负担，且不会带来什么好处。此时我们可以使用尾置返回类型。

```c++
/***********************
*尾置返回类型与类型转换。
************************/
template <typename T>
auto sum2(const T &a,const T &b) ->decltype(a+b)//将函数的返回类型指定为a+b的类型。
{
    return a + b;
}

int a3 = 566669;
int b3 = 59;
cout << sum2(a3, b3) << endl;//处理足够大小的数相加。
```

### 4 函数指针和实参推断

我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时。编译器会用指针的类型来推断模板。当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数能唯一确定其类型或值。

```c++
/*******************
*函数指针和实参推断。
********************/
template <typename T>
int compare(const T &a, const T &b)
{
    return a < b ? 1 : 0 ;
}

int (*p)(const int &, const int &) = compare;
cout << p(1, 2) << endl;//p是指向函数的指针,使用指针来推断模板实参为int。
```

### 5 模板实参推断和引用❤

**（1）从左值引用函数参数推断类型**

- 当一个函数类型参数是普通的左值引用时，规定只能传递给它一个左值（一个变量或一个引用的表达式），实参可以是const类型也可以不是。
- 如果实参是const类型，T将会被推断是const类型。如果函数类型参数是const&T时，我们可以传递任何类型的实参，一个对象，一个临时对象或者字面值常量。

**（2）从右值引用函数参数推断类型**
  我们可以传递一个右值，推断规则类似左值引用。左值不能绑定在右值引用上，但是有两个例外规则。

- 当我们将一个左值传递给函数的右值引用参数时，编译器推断模板类型参数为实参的左值引用类型。注意是引用。比如传递给模板函数参数T &&一个int i,推断出来的类型就是int &。

- 如果我们间接创建一个引用的引用就会形成引用折叠，引用折叠在大部分情况下会形成一个普通的左值引用，但是在右值引用的引用情况下会生成右值引用。

    X& &, X& &&和X&& &都折叠成X&

    X&& &&折叠成X&&

### 6 理解std::move❤

标准库move函数是使用右值引用模版的一个很好的例子，我们不能将一个右值的引用绑定到一个左值上，但是通过move函数就可以完成该操作，move可接收左值也可以接收右值。

```c++
/**************
*理解std::move。
***************/
//通过引用折叠，T &&可以与任意类型的实参匹配，左值和右值皆可。
template <typename T>
typename remove_reference<T>::type &&move(T &&t)
{
	return static_cast<typename remove_reference<T>::type &&>(t);
}

string s5 = std::move(string("Hi"));
```

### 7、 转发❤

某些函数需要将一个或多个实参连同类型传递给其他的函数，这种情况下我们需要保证实参的类型。

如果一个函数参数是指向模版类型参数的右值引用（T&&）,则它对应的实参的const属性和右值/左值属性将得到保持，但此方法不能用于接受右值引用的函数。

当用于一个指向模版参数类型的右值引用参数时（T&&），forward()会保持实参类型的每个细节，头文件为utility，后必须加显式模版参数。

## 16.3 重载与模板

函数模版可以被另一个模版或者普通非模版函数重载：相同名字函数，具有不同数量或者类型的参数。

**若模版被重载**，则函数的匹配会发生变化：

- 匹配过程中，候选函数包括所有的模版实参推断成功的模版实例。
- 可行函数按类型转换来排序，需要类型转换的排在不需要转换的后面。
- 若有多个函数提供同样的匹配：若是非模版函数，选择非模版函数。若没有非模版函数，则那个模版的特例高，选哪个，否则的话，此调用会产生歧义。

**注意：**

1. 若多个模版皆为精确匹配，正常情况下无法区分，但是更特例化的的模版排在前面，比如const T&和T*p，T *p更加特例化。
2. 对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。
3. 在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。

```c++
#include <iostream>
#include <vector>
#include <list>
#include <string>
using namespace std;

//所有模版的声明都需要在函数定义前声明。
template<typename T> void f(T t)  
{  
    cout<<"f:T t："<<t<<endl;  
}  
  
template<typename T> void g(T *t)  
{  
    cout<<"g:T *t："<<t<<endl;  
}  
  
template<typename T> void g(T t)  
{  
    cout<<"g:T t："<<t<<endl;  
}  
  
template<typename T> void f(const T *t)  
{  
    cout<<"f:const T*："<<t<<endl;  
}  

int main(int argc, char** argv)
{
    int i = 42,*p = &i;
    const int ci = 0, *p2 = &ci;

    g(42);//调用g(T t)
    g(p);//调用g(T *t)
    g(ci);//调用g(T t)
    g(p2);//调用g(T *t)
    f(42);//调用f(T t)
    f(p);//调用f(T t)
    f(ci);//调用f(T t)
    f(p2);//调用f(const T *t)
    system("pause");
    return 0;
}
```

## 16.4  可变参数模板

 	可变函数模版就是指一个接受可变数目参数的模版函数或者模版类，可变数目的参数被称为参数包，分为两种：模版参数包，表示零个或多个模版参数，函数参数包，表示零个或多个函数参数。利用一个省略号来表示一个模版参数或者函数参数为一个包。

​		使用sizeof…()运算符(注意有省略号)，值求出参数的数目。

### 1 编写可变参数函数模板

​		当定义可变参数版本的函数时，非可变参数版本的声明必须在作用域中，否则，可变参数版本会无限递归。好的做法是都在最开始声明。

```c++
/*********************
*编写可变参数函数模板。
**********************/

template<typename T>
//非可变参数版本，递归的最后一次调用会选择该版本，因为比较特例化。
//必须声明在可变参数模板的定义之前，否则可变参数模板会无限递归。
std::ostream &print(std::ostream &os, const T &t)
{    
    return os << t;    
}    
template<typename T, typename... Args>    
std::ostream &print(std::ostream &os,const T &t,const Args&... args)    
{    
    os << t << ", ";
    return print(os, args...); 
}    

print(cout, 42) << endl;
print(cout, 42, a) << endl;
print(cout, 42, a, q, "hello", 'w') << endl;
```

### 2 包扩展

​		对于一个参数包，我们还可以对其进行参数扩展，即将一个包分解为其构成元素，我们通过在模式的右边放一个省略号…来出发扩展操作。
  我们还可以对作为参数的函数进行扩展，但注意省略号的位置，不是对函数参数的扩展。

```c++
//打印我们不能处理的类型。
template<typename T>    
std::string debug_rep(const T &s)    
{    
    std::ostringstream ret;    
    ret << s;    
    return ret.str();//返回ret绑定的string的一个副本。
} 

//打印指针的值，后跟指针指向的对象。
template<typename T>    
std::string debug_rep(T *p)    
{    
    std::ostringstream ret;    
    std::cout << "point:" << p;//打印指针本身的值。 
    if (p)    
        ret << " " << debug_rep(*p);    
    else    
        ret << "point is NULL!";    
    return ret.str();    
} 

//打印双引号包围的string。
std::string debug_rep(const std::string &s)    
{    
    return '"' + s + '"';    
}    

//将字符指针转换为string，并调用string版本的debug_rep。
std::string debug_rep(char *p)    
{    
    return debug_rep(std::string(p));    
}    
    
std::string debug_rep(const char *p)    
{    
    return debug_rep(std::string(p));    
}    

//包扩展：参数包中每个元素调用debug_rep。
template<typename... Args>    
std::ostream &errorMsg(std::ostream &os, const Args... args)    
{    
    return print(os, debug_rep(args)...);    
}    

string str = "c++";    
errorMsg(cout, str, "primer", 4, 8.6, '5'); 
```

## 16.5 模板特例化

当我们不能（或者不希望）使用模版版本时，我们可以定义类模版或者函数模版的一个特例化版本：比如说函数模版中的处理不适用于未定义<运算符（指针类型）的情况，我们就可以特例化一个版本已使用特殊情况。一个特例化版本就是模版的一个独立的定义，在其中一个或者多个参数被特定为指定的类型
  在为函数模版特例化时，必须为函数模版的每个模版参数提供实参，尖括号中的模版参数去掉，但是必须提供实参。
**注意：**

1. 特例化的本质是实例化一个模版，而非重载，因此特例化不影响函数的重载，它不是一个非模版的独立函数。
2. 模版及其特例化版本应该定义在一个头文件中，所有同名的模版的声明应该放在前面，然后是这些特例化的声明。
3. 类模版也可以进行特例化，需要在原模版定义所在的命名空间中特例化。

```c++
#include <bits/stdc++.h>   
class Sales_data    
{    
    std::string bookNo;    
    unsigned units_sold;    
    double revenue;    
    double avg_price()const { return units_sold ? revenue / units_sold : 0; }    
public:    
    Sales_data(const std::string &s=std::string(), unsigned n = 0, double p = 0) :bookNo(s), units_sold(n), revenue(p) {}    
    Sales_data(std::istream &is);    
    std::string isbn()const { return bookNo; }    
    Sales_data &operator+=(const Sales_data &s);    
    friend std::hash<Sales_data>;    
    friend std::ostream &operator<<(std::ostream &os, const Sales_data &s);    
    friend std::istream &operator>>(std::istream &is, Sales_data &s);    
    friend bool operator==(const Sales_data &ls, const Sales_data &rs);    
    friend Sales_data operator+(const Sales_data &ls, const Sales_data &rs);    
    friend std::ostream &print(std::ostream &os, const Sales_data &s);    
    friend std::istream &read(std::istream &is, Sales_data &s);    
};    
bool operator!=(const Sales_data &ls, const Sales_data &rs);    
Sales_data add(const Sales_data &ls, const Sales_data &rs);    
    
namespace std    
{    
    template<> //特例化一个版本，模板参数为Sales_data。
    struct hash<Sales_data>    
    {    
    	//用来散列一个无序容器的类型必须定义以下类型。
        typedef size_t result_type;    
        typedef Sales_data argument_type;    
        size_t operator()(const Sales_data &s)const {   
        	//对哈希值进行异或运算。 
            return hash<string>()(s.bookNo) ^ hash<unsigned>()(s.units_sold) ^ hash<double>()(s.revenue);    
        }    
    };    
}    

Sales_data::Sales_data(std::istream &is)    
{    
    is >> *this;    
}    
    
Sales_data &Sales_data::operator+=(const Sales_data &s)    
{    
    units_sold += s.units_sold;    
    revenue += s.revenue;    
    return *this;    
}    
    
std::ostream &operator<<(std::ostream &os, const Sales_data &s)    
{    
    os << s.isbn() << " " << s.units_sold << " " << s.revenue << " " << s.avg_price();    
    return os;    
}    
    
std::istream &operator>>(std::istream &is, Sales_data &s)    
{    
    double price;    
    is >> s.bookNo >> s.units_sold >> price;    
    if (is)    
        s.revenue = s.units_sold*price;    
    else    
        s = Sales_data();    
    return is;    
}    
    
bool operator==(const Sales_data &ls, const Sales_data &rs)    
{    
    return ls.bookNo == rs.bookNo&&ls.units_sold == rs.units_sold&&ls.revenue == rs.revenue;    
}    
bool operator!=(const Sales_data &ls, const Sales_data &rs)    
{    
    return !(ls == rs);    
}    
    
Sales_data operator+(const Sales_data &ls, const Sales_data &rs)    
{    
    Sales_data temp = ls;    
    temp += rs;    
    return temp;    
}    
    
Sales_data add(const Sales_data &ls, const Sales_data &rs)    
{    
    Sales_data temp = ls;    
    temp += rs;    
    return temp;    
}    
    
std::ostream &print(std::ostream &os, const Sales_data &s)    
{    
    os << s.isbn() << " " << s.units_sold << " " << s.revenue << " " << s.avg_price();    
    return os;    
}    
    
std::istream &read(std::istream &is, Sales_data &s)    
{    
    double price;    
    is >> s.bookNo >> s.units_sold >> price;    
    s.revenue = s.units_sold*price;    
    return is;    
}    

int main()    
{    
    std::unordered_multiset<Sales_data> mset;    
    Sales_data sd("Bible", 10, 0.98);    
    
    mset.emplace(sd);    
    mset.emplace("C++ Primer", 5, 9.99);    
    
    for (const auto &item : mset)    
        std::cout << "the hash code of " << item.isbn()    
        << ":\n0x" << std::hex << std::hash<Sales_data>()(item)    
        << "\n";    
    system("pause");    
    return 0;    
}    
```

## 补充：SFINAE❤

SFINAE 是C++ 11 推出的一种模板匹配机制，SFINAE最主要的作用，是保证编译器在泛型函数、偏特化、及一般重载函数中遴选函数原型的候选列表时不被打断。

简单来说就是SFINAE机制可以在编译器进行函数匹配发生Error时，并不会立即报错，而是继续查找正确匹配的模板，可以利用该机制完成对不同类型的同种操作的分类的操作

```c++
template<typename A>
struct B { using type = typename A::type; };

template<
    class T,
    class U = typename T::type,    // 如果 T 没有成员 type 那么就是 SFINAE 失败
    class V = typename B<T>::type> // 如果 T 没有成员 type 那么就是硬错误
                                   // （经由 CWG 1227 保证不出现，
                                   // 因为到 U 的默认模板实参中的替换会首先失败）
void foo (int);

template<class T>
typename T::type h(typename B<T>::type);

template<class T>
auto h(typename B<T>::type) -> typename T::type; // 重声明

template<class T>
void h(...) {}

using R = decltype(h<int>(0));     // 错误格式，不要求诊断
```

```c++
template <int I>
struct X {};

template<template<class T> class>
struct Z {};

template<class T>
void f(typename T::Y*) {}

template<class T>
void g(X<T::N>*) {}

template<class T>
void h(Z<T::template TT>*) {}

struct A {};
struct B { int Y; };
struct C { typedef int N; };
struct D { typedef int TT; };
struct B1 { typedef int Y; };
struct C1 { static const int N = 0; };
struct D1
{
    template<typename T>
    struct TT {};
};

int main()
{
    // 下列各个情况推导失败：
    f<A>(0); // 不含成员 Y
    f<B>(0); // B 的 Y 成员不是类型
    g<C>(0); // C 的 N 成员不是非类型
    h<D>(0); // D 的 TT 成员不是模板

    // 下列各个情况推导成功：
    f<B1>(0);
    g<C1>(0);
    h<D1>(0);
}
// 未完成：需要演示重载决议，而不只是失败
```