# C15 面向对象程序设计

## 15.1 OOP概述

**面向对象程序设计**的核心思想是：**数据抽象（类）**，**继承**和**动态绑定**。通过数据抽象：我们可以将类的接口和实现分离。使用继承：可以定义相似的类型并对其相似关系建模。使用动态绑定：可以在一定程度上忽略相似类型的区别，而以统一的方式使用他们的对象。

某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明为虚函数。

**不能被继承：**构造函数（C++11使用using声明可“继承”）；析构函数；私有成员函数；赋值操作符；友元函数。

函数的运行版本由实参决定，既在运行时选择函数的版本，所以**动态绑定**有时被称为运行时绑定。

c++中，我们使用**基类的引用**或**指针调用一个虚函数**时会发生动态绑定

## 15.2 定义基类和派生类

### 1 定义基类

- 基类通常都应该定义一个虚构函数，即使虚构函数不执行任何实际操作也是如此。
- 派生类可以继承基类的成员，派生类需要对这些操作提供自己的新定义以覆盖（override）从基类继承而来的就定义。
- 任何构造函数之外的非静态函数都可以是虚函数，关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。
- c++是静态类型的语言，其解析过程发生在编译期间，但对于虚函数是在运行期间动态绑定。

```c++
class Quote{
public:
	Quote() = default;
	Quote(const std::string &book, double sales_price):
    					bookNo(book), price(sales_price){}
	std::string isbn() const { return bookNo; }
	//返回给定数量的书籍的销售总额。
	virtual double net_price(std::size_t n) const
	{
		return n * price;
	}
	//对析构函数进行动态绑定。
	virtual ~Quote() = default;
private:
	std::string bookNo;   //书籍的ISBN编号
protected:
	double price = 0.0;  //普通状态下不打折的价格
};
```

### 2 定义派生类

```c++
class Bulk_quote : public Quote //Bulk_quote继承自Quote
{
public:
	Bulk_quote() = default;
	Bulk_quote(const std::string& , double , std::size_t , double);
    //覆盖基类的函数版本以实现基于大量购买的折扣政策。
	double net_price(std::size_t) const override;
private:
	std::size_t min_qty = 0;//最低购买量。
	double discount = 0.0;//折扣率。
};
```

- 派生类必须通过使用派生类列表明确指出它是从哪个基类继承而来的。
- 派生类需要对其继承而来的成员函数中需要覆盖的那些进行重新声明。派生类经常覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

**派生类对象及派生类向基类的类型转换**

一个派生类对象包含多个组成部分：

1. 一个含有派生类自己定义的（非静态）成员的子对象
2. 一个与该派生类继承的基类对应的子对象。

在一个对象中，派生类继承基类的部分和派生类的部分不一定是连续存储的。

在我们的例子中，Bulk_quote对象包含两部分

![90](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308101707400.png)

因为派生类对象中包含与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，我们也能将基类的指针或引用绑定到派生类对象的基类部分。这种称为**派生类到基类的类型转换**，编译器会隐式的执行转换。

**派生类构造函数**

每个类控制他自己的成员初始化过程。每个类控制他自己的成员初始化过程。派生类构造函数通过构造函数初始化列表将实参传递给基类构造函数。

Bulk_qoute的构造函数如下

```c++
Bulk_quote::Bulk_quote(const std::string& book, double p,
					   std::size_t qty, double disc) :
	Quote(book, p), min_qty(qty), discount(disc) {};

```

**派生类使用基类成员**

派生类可以访问基类公有成员和受保护成员。派生类作用域嵌套在基类的作用域之内

👌**注意**：派生类对象不能直接初始化基类成员，从语法来看可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但最好不这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。

**继承与静态成员**

若在基类中定义了一个静态成员，那么在整个体系中只存在该成员的唯一定义。不论基类有多少个派生类，对每个静态成员来说都只存在一个唯一的实例。

**被用作基类的类**

如果某个类用作基类，则该类必须定义而非仅仅声明

**防止继承的发生**

有时我们不希望类被继承，我们可以在类名后跟一个关键字final

```c++
class NoDerived final{/*...*/};   //NoDerived不能作为基类
class Base{/*...*/};  
//Last是final的 我们不能继承last
class Last final:Base{ /*...*/ };   //Last不能作为基类
class Bad:NoDerived{ /* */ };       //错误：NoDerived是final的
class Bad2:Last{ /* */ };           //错误：Last是final的
```

### 👌3 类型转换与继承

我们可以将基类的指针或引用绑定到派生类对象上。当使用基类的引用（或指针）时，我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可以是基类的对象，也可以是派生类的对象。例如，我们可以将Quote&指向一个Bulk_qoute对象，也可以将Bulk_quote对象的地址赋给Quote*。

**静态类型与动态类型**

当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的**静态类型**与该表达式表示对象的**动态类型**区分开。基类的指针或引用的静态类型可能与动态类型不一致。若表达式**不是**引用或指针，则它的动态类型永远与静态类型一致。

```c++
Bulk_quote bq;
 
Quote* q=&bq;
```

**不存在从基类向派生类的隐式类型转换**

```c++
Quote base;
Bulk_quote* bulkp = &base;   //错误:不能将基类转换成派生类
Bulk_quote& bulkRef = base;  //错误：不能将基类转换成派生类

//即使基类指针或引用绑定在派生类对象上，我们也不能执行从基类向派生类的转换
Bulk_quote bulk;
Quote *itemP = &bulk;    //正确：动态类型是Bulk_quote
Bulk_quote *bulkP = itemP;    //错误：不能将基类转换成派生类
```

因为编译器只能通过检查静态类型来判断转换是否合法，所以即使基类指针或引用绑定在派生类对象上，我们也不能执行从基类向派生类的转换。若我们已知某个转换是安全的，那么我们可以使用❤**static_cast**来强制覆盖掉编译器的检查工作。

**在对象之间不存在类别转换**

派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换，很多时候，我们希望派生类对象转换为基类对象，但这种转换过程往往与我们预计有所差别。

```c++
Bulk_quote bulk;    //派生类对象
Quote item(bulk);   //使用Quote::Quote(const Quote&)构造函数
item = bulk;        //调用Quote::operator=(const Quote&)
```

上述过程中会忽略Bulk_quote部分，所以我们可以说Bulk_quote部分被**切掉**了。
当我们用一个派生类对象为一个基类对象初始化或赋值时，只有派生类对象中的基类部分被拷贝、移动或赋值，它的派生类部分被忽略掉。

## 15.3 虚函数

当我们使用基类的引用或指针调用调用一个虚成员函数会执行动态绑定，因为在运行的时候我们才知道调用了哪个版本的虚函数，所有虚函数都必须有定义。

**对虚函数的调用可能在运行时才被解析**

```c++
double print_total(ostream &os, const Quote &item, size_t n){
    //根据传入item的形参的对象类型调用Quote::net_price或Bulk_quote
    double ret = item.net_price(n);
    os << "ISBN:" << item.isbn()  //调用Quote::isbn()
       << "# sold: " << n << "total due:" << ret <<endl;
    return ret;
} 
```

```c++
Quote base("0-201-82470-1", 50);
print_total(cout, base, 10);     //调用Quote::net_price
Bulk_quote derived("0-201-82470-1", 50, 5, .19);
print_total(cout, derived, 10);  //调用Bulk_quote::net_price 
```

**动态绑定只有当我们通过指针或引用调用虚函数时才会发生**

```c++
base = derived;       //把derived的Quote部分拷贝给base
base.net_price(20);   //调用Quote::net_price
```

当我们通过一个具有普通类型的表达式调用虚函数时，在编译时调用版本就被确定下来。

引用或指针的静态类型与动态类型不同正是C++支持多态性的根本所在。

**派生类中的虚函数**

派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。

**final和override说明符**❤👌

派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是一个合法的行为。编译器认为这个函数与原有函数相互独立，这时，派生类的函数并没有覆盖基类中的版本。这种声明一般意味着发生了错误且这种错误较难被发现。C++11我们可以使用override。

```c++
struct B {
	virtual void f1(int) const;
	virtual void f2();
	void f3();
};

struct D1:B{
	void f1(int) const override;
	void f2(int) override;       //错误 B中没有形如f2(int)的参数
	void f3() override;          //错误 f3不是虚函数
	void f4() override;          //错误 B中没有名为f4的函数
};

struct D2:B{
	//从B继承f2()、f3(),覆盖f1(int)
	void f1(int)const final; //不允许后续的其他类覆盖f1(int)
};
struct D3:D2{
	void f2();              //正确  覆盖从间接基类B继承来的f2
	void f1(int) const;     //错误  D2已经将f1声明成了final

};
```

**虚函数与默认实参**👌

和其他函数一样，虚函数也可以有默认实参，函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。当我们通过基类的引用或指针调用函数，则使用基类定义的默认实参，即使实际运行的是派生类的函数版本。因此，如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

**回避虚函数的机制**

在某些情况下，我们希望对虚函数调用不能进行动态绑定，而是强迫其执行虚函数的某个特定版本，使用作用域运算符可以实现。通常情况下，只有成员函数(友元函数)中的代码才需要使用作用域运算符来回避虚函数机制。

```c++
double undiscounted = baseP->Quote::net_price(42);
```

一般派生类虚函数调用其覆盖的基类版本时需要回避虚函数的机制。如果派生类虚函数调用其基类版本却没有使用作用域运算符，则会被解析为对派生类版本自身的调用，导致无限递归。

## 15.4 抽象基类

**纯虚函数**👌（结合书上的例子）

定义成纯虚函数，这么做可以清晰明了地告诉用户该函数没有实际意义，和普通的虚函数不一样，纯虚函数不需要定义。我们通过在函数体的位置(即在声明语句的分号之前)书写=0就可以将一个虚函数说明为纯虚函数，其中，=0只能出现在类内部的虚函数声明语句之处。

```c++
//用于保存折扣值和购买量的类，派生类可以使用这些数据实现不同的价格策略（不同购买量对应不同折扣值）
class Disc_quote :public Quote {
public:
	Disc_quote() = default;
	Disc_quote(const string& book, double price,
		size_t qty, double disc) :
		Quote(book, price),
		quantity(qty), discount(disc) {};
	double net_price(size_t) const = 0;
protected:
	size_t quantity;     //折扣适用购买量
	double discount = 0; //表示折扣的小数值
};
```

我们可以为纯虚函数提供定义，不过函数体必须定义在类的外部，也就是说，我们不能在类的内部为一个=0的函数提供函数体。

**含有纯虚函数的类是抽象基类**

含有纯虚函数的类是抽象基类，抽象基类负责定义接口，而后续的其它类可以覆盖该接口，我们不能(直接)创建一个抽象基类的对象。

```c++
//Disc_quote声明了纯虚函数，而Bulk_quote将覆盖该函数
Disc_quote discounted; //错误 不能定义抽象基类的对象
Bulk_quote bulk;       //正确 Bulk_quote中没有纯虚函数
```

**派生类构造函数只初始化它的直接基类**

```c++
class Bulk_quote :public Disc_quote {
public:
	Bulk_quote() = default;
	Bulk_quote(const string& book, double price,
		size_t qty, double disc) :
		Disc_quote(book, price, qty, disc) {};
	//覆盖基类中的函数版本以实现一种新的折扣策略
	double net_price(size_t n) const override;
};
```

当前版本的Bulk_quote直接基类是Disc_quote，间接基类是Quote。每个Bulk_price对象包含三个子对象：一个（空的）Bulk_quote部分、一个Disc_quote部分的子对象和一个Quote子对象。如前所述，每个类各自控制其对象的初始化过程。（👌书上补充）

**重构**（👌查+书上补充）

## 15.5 访问控制与继承👌

**受保护的成员**

protected说明符可以看作是public和private中和后的产物

1. 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。
2. 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。
3. 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。

```c++
class Base {
protected:
	int prot_mem;
};

class Sneaky :public Base {
	friend void clobber(Sneaky&);   //可以访问Sneaky::prot_mem
	friend void clobber(Base&);     //不能访问Base::prot_mem
	int j;                          //默认private
};
//正确  可以访问
void clobber(Sneaky &s) {
	s.j = s.prot_mem = 0;
}
//错误 不能访问
void clobber(Base &b) {
	b.prot_mem = 0;
}
```

**公有、私有和受保护继承**

1. **公有继承(public)**

     公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。

2. **私有继承(private)**

    私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。

3. **保护继承(protected)**

     保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。

```c++
class Base {
public:
	void pub_mem();     //public成员
protected:
	int prot_mem;       //protected成员
private:
	char priv_mem;      //private成员
};

struct Pub_Derv :public Base {
	 //正确 派生类可以访问受保护成员
	int f() { return prot_mem; }
	//错误 派生类不可以访问私有成员
	char g() { return priv_mem; }
};

struct Priv_Derv :private Base {
	//正确 private不影响派生类的访问权限
	int f1() const { return prot_mem; }
};
```

派生类访问说明符对于派生类的成员（友元）能否访问基类成员没有什么影响。对基类成员的访问权限只与基类中的访问说明符有关。Pub_Derv与Priv_Derv都可以访问受保护成员prot_mem,同时都不能访问Priv_mem.
派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限：

```c++
Pub_Derv d1;    //继承的Base成员是public的
Priv_Derv d2;   //继承自Base成员是private的
di.pub_mem;     //正确 pub_mem在派生类中是public的
d2.pub_mem;     //错误 pub_mem在派生类中是private的
```

派生访问说明符还可以控制继承自派生类的新类的访问权限：

```c++
struct Derrived_from_public :public Pub_Derv {
	//正确 Base::prot_mem在Pub_Derv中仍然是protected
	int use_base() { return prot_mem; }
};

struct Derived_from_public :public Priv_Derv {
	//错误 Base::prot_mem在Priv_Derv中是private的
	int use_base() { return prot_mem; }
};
```

**派生类向基类转换的的可访问性**

1. 只有当派生类公有的继承基类时，用户代码才能使用派生类向基类的转换，如果派生类继承基类的方式是受保护的或者私有的，则用户代码不能使用该转换。 
2. 不论派生类以什么方式继承基类，派生类的成员函数和友元都能使用派生类向基类的转换，派生类向其直接基类的类型转换对于派生类的成员和友元来说是永久可访问的。  
3. 如果派生类继承基类的方式是共有的或者受保护的，则派生类的成员和友元可以使用派生类向基类的类型转换，反之，如果派生类继承基类的方式是私有的，则不能使用。

**友元与继承**

友元关系不能传递，友元关系也不能继承。基类的友元在访问派生类成员时不具有特殊性，派生类的友元也不能随便访问基类的成员。当一个类将另一个类声明为友元时，这种友元关系只对做出声明的类有效，对于原来的那个类来说，其友元的基类或者派生类不具有特殊的访问能力。

**改变个别成员的可访问性**

```c++
class Base {
public:
	size_t size() const { return n; }
protected:
	size_t n;
};

class Derived :private Base {   //注意，private继承
public:
	using Base::size;
protected:
	using Base::n;
};
```

上述例子，默认情况下使用了私有继承，继承而来的size和n是私有成员，使用using声明语句可以变该其可访问性。改变之后，派生类用户可以使用size成员，而派生类的派生类将能使用n。

**默认的继承保护级别**

```c++
class Base{ /*...*/ };
struct D1: Base{ /*...*/ };    //默认为public继承（struct默认成员访问说明符public）
class D2: Base{ /*...*/ };     //默认为private继承（class...private）
```

## 15.6 继承中的类作用域

每个类定义自己的作用域，在这个作用域内我们定义类的成员，当存在继承关系时，派生类的作用域嵌套在其基类作用域之内。如果一个名字在自己的作用域内无法解析，那么就会在基类中查找。

**在编译时按名字查找**

👌（下面这段代码与前面结合，15.2.3）

```c++
class Disc_quote :public Quote {
public:	
	pair <size_t, double> discount_policy() const
	{ return { quantity,discount };	}
	//其他成员
};
    Bulk_quote bulk;
	Bulk_quote *bulkP = &bulk;   //静态类型与动态类型一致
	Quote *itemP = &bulk;       //动态类型与静态类型不一致
	bulkP->discount_policy();  //正确：类型为Bulk_Quote
	itemP->discount_policy(); //错误：Quote无这个成员
```

**名字冲突与继承**

```c++
struct Base{
   Base():mem(0){}
protected:
   int mem;
};
struct Derived : Base{
   Derived(int i): mem(i){ }
   int get_mem() { return mem; }
protected:
   int mem;                //将隐藏基类的mem
};
Derived d(42);
cout << d.get_mem() <<endl;   //打印42
```

**通过作用域运算符来使用隐藏的成员**

```c++
struct Derived:Base{
   int get_Base_mem{ return Base::mem; }
   //...
};

Derived d(42);
cout << d.get_base_mem()<<endl;   //打印0
```

**重载、覆盖和隐藏的区别**👌

- **重载**：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。

- **隐藏**：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。

- **覆盖**：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

**名字查找优先于类型检查**
声明在内层作用域的函数并不会重载声明在外层作用域的函数，因此，定义在派生类的函数也不会重载基类中的成员。

**覆盖重载的函数**👌❤

和其他函数一样，成员函数无论是否为虚函数都能被重载。派生类可以覆盖重载函数的0个或者多个实例，如果派生类希望所有的重载版本对于它来说都是可见的，那它就需要从覆盖所有版本，或者一个也不覆盖。使用using声明语句指定一个名字而不指定形参列表，因此可以将所有重载实例添加到派生类作用域中，派生类此时仅需定义特有的函数。

## 15.7 构造函数与拷贝控制

### 1 虚析构函数（👌ppt不要合成移动）

继承关系对基类拷贝控制最直接的影响是基类通常定义一个**虚析构函数**，这样我们就能动态分配继承体系中的对象了。
例如:如果我们delete一个Quote*类型的指针，则该指针有可能实际指向了一个Bulk_quote类型的对象，那么这样的话，编译器必须清楚他执行的是Bulk_quote的虚构函数，和其他函数一样，我们在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本：

```c++
class Quote{
	//如果我们删除的是一个指向派生类对象的基类指针，则需要析构函数
	virtual ~Quote() = default;  //对析构函数进行动态绑定
};

Quote *itemP = new Quote;       //动态类型与静态类型一致
delete itemP;                   //调用Quote析构函数
itemP = new Bulk_quote;         //静态类型与动态类型不一致
delete itemP;                   //调用Bulk_quote析构函数 
```

如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。

**虚析构函数将阻止合成移动操作**

如果一个类定义了析构函数，即使它通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

### 2 合成拷贝控制与继承❤

1. 合成的Bulk_quote默认构造函数运行Disc_quote的默认构造函数，后者又运行Quote的默认构造函数。
2. Quote的默认构造函数将bookNo成员默认初始化为空字符串，同时使用类内初始值price初始化为0.
3. Quote构造函数完成后，继续执行Disc_quote的构造函数，它使用类内初始值初始化qty和discount
4. Disc_quote的构造函数完成后，继续执行Bulk_quote的构造函数，但是它什么工作都不做。

**派生类中删除的拷贝控制和基类的关系**

基类永远会影响派生类，因为派生类继承基类，如果基类拷贝控制部分操作有问题，那么派生类也会有。比如：基类的拷贝构造定义为删除的，那么派生类也必定为删除的，因为派生类中的拷贝构造必须要调用基类的拷贝构造来初始化基类部分，基类定义为删除的，说明派生类不能构造基类部分，那么派生类也就为删除的了。


### 3 派生类的拷贝控制成员

`派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还要负责初始化派生类对象的基类部分，因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员，类似的派生类赋值运算符也必须为其基类部分的成员赋值。和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。`

当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。

**定义派生类的拷贝或移动构造函数**

```c++
class Base{ /* */ };
class D:public Base{
public:
    //默认情况下，基类的默认构造函数初始化对象的基类部分
    //要想使用拷贝或移动构造函数，我们在构造函数初始值列表中显式调用该构造函数
    D(const D& d): Base(d)  //拷贝基类成员
            { }  
    D(D&& d): Base(std::move(d))       //移动基类成员
            { }
};
```

**派生类赋值运算符**

与拷贝和移动构造函数一样，派生类的赋值运算符也必须显示地为基类部分赋值

**派生类析构函数**

对象的基类部分是隐式销毁的，和构造函数及赋值运算符不同，派生类析构函数只负责销毁由派生类自己分配的资源。

**在构造函数和析构函数中调用虚函数**（❤）

### 4 继承的构造函数

在C++11标准中，派生类可以重用其直接基类定义的构造函数。

```c++
class Bulk_quote:public Disc_quote{
public:
     //继承Disc_quote的构造函数
    using Disc_quote::Disc_quote;
    //其他成员
};
```

编译器会生成构造函数形如:`derived(parms) :base(args){ }`

```c++
 //derived是派生类名字，base是基类的名字，parms是构造函数的形参列表，args将派生类构造函数的形参传递给基类的构造函数
Bulk_quote(const string& book, double price,
           size_t qty, double disc):
           Disc_quote(book, price, qty, disc){}
 //如果派生类有自己的数据成员，那么这些成员将被默认初始化
```

**继承的构造函数的特点**

- 和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。
- 而且，一个using声明语句不能指定explicit或constexpr。如果基类的构造函数是explicit或者constexpr，则继承的构造函数也有相同的属性。
- 当一个基类构造函数含有**默认实参**，这些实参并**不会被继承**



## 15.8 容器与继承

当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式，因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器中。

**注意**：
1）当派生类对象被赋值给基类对象时，其中的派生类部分将被切掉，因此容器和存在继承关系的类型无法兼容。
2）应该在容器中放置**（智能）指针**❤👌而非对象。

正如我们可以把派生类的指针转换为基类的指针一样，我们也可以把派生类的智能指针转换为基类的智能指针。



## 补充：菱形继承与虚继承、虚表

### **虚表**

一个类存在虚函数，那么编译器就会为这个类生成一个虚函数表，在虚函数表里存放的是这个类所有虚函数的地址（虚表从属于类）。编译器会为包含虚函数的类加上一个成员变量，该成员变量是一个指向虚函数表的指针，因此虚表指针是一个成员属性，也就是说，如果一个类含有虚表，那么类的每个对象都含有虚表指针。 这张表解决了继承、覆盖的问题，指明了实际所应该调用的函数。

1.

```c++
class A
{
public: 
    virtual void f1()
    {
        cout << "A::f1()" << endl;
    }
    virtual void f2()
    {
        cout << "A::f2()" << endl;
    }
    virtual void f3()
    {
        cout << "A::f3()" << endl;
    }
    int _a;
};
```

这样一个A类的虚函数地址如下所示：**即一个普通的基类的虚函数地址按照声明顺序排列**

![93](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308102330770.png)

2.若一个继承了A类的派生类B的虚函数表，但是B类的虚函数并没有覆盖A类的虚函数，没有构成重写

```c++
class B :public A
{
public:
    virtual void f4()
    {
        cout << "B::f4()" << endl;
    }
    virtual void f5()
    {
        cout << "B::f5()" << endl;
    }
    int _b;
};
```

虚函数表如下所示：**即无虚函数覆盖的子类所构成的虚函数表的函数指针存放时父类的虚函数在子类的前面，按照声明顺序排列**

![94](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308102337136.png)

3.一个继承了A类的派生类C的虚函数表，并且构成重写，还有自己的虚函数。

```c++
class C :public A
{
    virtual void f1()
    {
        cout << "C::f1()" << endl;
        cout << endl;
    }
    virtual void f5()
    {
        cout << "C::f5()" << endl;
        cout << endl;
    }
    int _c;
};
```

![95](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308102339921.png)

**存在虚函数的重写时，虚函数表中覆盖的函数用子类的虚函数代替其余顺序不变，先完成父类的虚函数地址的存放，再存放子类的非覆盖的函数。**

4.菱形继承的类D,拥有自己的虚函数，还有与父类构成重写的虚函数

![96](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308102343689.png)



![97](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308102345980.png)

菱形继承的B类和C类都拥有自己的虚函数表，而子类的虚函数被放在了第一个被声明的父类中（即public D :public B, public C）。B类的虚表拥有A类、B类、C类的虚函数，B类的虚表排列顺序为：假如D类的虚函数构成重写，就换成D类的虚函数，D类没有构成重写，就看B类是否构成重写，B类构成重写排B类的虚函数，然后再排A类没有在B类和C类没有构成重写的虚函数，接着排B类没有构成重写的虚函数，最后排D类没有构成重写的函数，C类的虚表类似。

5.菱形继承的类D，且为虚继承，每个子类都拥有一个没有构成重写的虚函数和一个构成重写的虚函数。

![98](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308102349398.png)



虚表的构成如下：

![99](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308102358542.png)

注：这里每个子类都有一个虚函数是父类没有的所以有三个虚表
可以看到菱形继承且存在虚继承的时候对象d的三个虚表构成为：A类有一个自己的虚表，存放自己的虚函数，如果子类重写了A类的虚函数，那么就用子类的替代（首先应该从D类找是否构成虚函数的重写，再从 C类和B类找是否构成重写）；由于在继承的时候B类先声明，所以将D类虚函数放在B类中，A类有的虚函数去掉，在B类和D类找A类没有的虚函数，剩下的构成重写的用子类D的虚函数替代就好了；C类的虚表就是直接将A类有的虚函数去除（如果全有的话，就少一张虚表），剩下的按照声明的顺序排列在C类的虚表中。

```C++
class A
{
public:
    virtual void f1()
    {
        cout << "A::f1()" << endl;
        cout << endl;
    }
    virtual void f2()
    {
        cout << "A::f2()" << endl;
        cout << endl;
    }
    int _a;
};
class B :virtual public A
{
public:
    virtual void f1()
    {
        cout << "B::f1()" << endl;
        cout << endl;
    }
    virtual void f3()
    {
        cout << "B::f3()" << endl;
        cout << endl;
    }

    int _b;
};
class C :virtual public A
{
public:
    virtual void f1()
    {
        cout << "C::f1()" << endl;
        cout << endl;
    }
    virtual void f4()
    {
        cout << "C::f4()" << endl;
        cout << endl;
    }
    int _c;
};
class D :public B,public C
{
public:
    virtual void f1()
    {
        cout << "D::f1()" << endl;
        cout << endl;
    }

    virtual void f5()
    {
        cout << "D::f5()" << endl;
        cout << endl;
    }
    int _d;
};
```



### **菱形继承**

1.单继承：一个子类只有一个直接父亲时称这个继承关系为单继承。
2.多继承：一个子类有两个或者以上直接父类时称这个继承关系为多继承。
3.菱形继承：菱形继承是多继承的一种特殊情况。两个子类继承同一父类，而又有子类同时继承这两个子类。例如B,C两个类同时继承A，但是又有一个D类同时继承B,C类。
4.菱形继承的问题：从对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。
5.虚拟继承可以解决菱形继承的二义性和数据冗余的问题。
![91](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308102259789.png)

```C++
class A 
{
public:
    int  _a;
};

class B :public A 
{
public:
    int _b;
};
class C :public A
{
public:
    int _c;
};
class D :public B,public C
{
public:
    int _d;
};
```

菱形继承的对象模型如下图所示

![92](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308102306406.png)

D的对象中有两份A成员，造成了数据的冗余。d的大小为20个字节。同时这会造成基类子对象重复，即二义性。

可以显示的指定访问哪个父类的成员，但是这个还是不能从根本上解决这个问题

```c++
D d;
d._a;
d.B::_a;
//或者d.C::_a;
```

本质上解决上述问题，需要采用虚继承。虚继承是一种机制，类通过虚继承指出它希望共享虚基类的状态。对给定的虚基类，无论该类在派生层次中作为虚基类出现多少次，只继承一个共享的基类子对象，共享基类子对象称为虚基类。虚基类用virtual声明继承关系就行了。这样一来，D就只有A的一份拷贝。

```c++
class A 
{
public:
    int  _a;
};
class B : virtual public A 
{
public:
    int _b;
};
class C :virtual public A
{
public:
    int _c;
};
class D :public B,public C
{
public:
    int _d;
};


D d;
d._a=4;
d._b=1;
d._c=2;
d._d=3;
```

使用虚继承后d的大小并不是期望中的16字节，而是24个字节。

在虚继承（菱形继承）中，对于类D创建的对象d，为了避免A类中的变量重复，所以，**将A类中成员变量放在d对象模型的最下面，由B类与C类各自虚基表指针访问虚基表中偏移量的方式进行访问A类成员变量**

