# B+树基础

## 1 B树

1. 定义任意非叶子结点最多只有M个儿子；且M>2；
2. **根结点的儿子**数为[2, M]；
3. 除根结点以外的**非叶子结点的儿子数**为[M/2, M]；
4. 每个结点存放至少M/2-1（取上整）和至多M-1个**关键字**；（至少2个关键字）
5. 非叶子结点的关键字个数=指向儿子的指针个数-1；
6. 非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]；
7. 非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；
8. 所有叶子结点位于同一层；



![100](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308171007170.png)

### 插入操作

首先跟查找一样，先进行比较。最终找到合适的位置，也就是（0013,0015）这个节点。将16插入该节点，变成（0013,0015,0016）。由于元素个数k大于了m-1（这是一个三阶B-树，m-1=2）。为了符合B-树的那几个特性，将会优先更加父节点的元素个数。向上传递元素，传递的原则就是中间值优先，所以传递元素为15。但是父节点也要符合B-的特性。由于元素个数也超了，所以再往上一级传递元素，传递元素为12。最终到了根节点，变成了（0008,0012）。此时根节点需要有三个子孩子。所以将根节点的右孩子，拆分成了两个。至此，调整完成，完全符合B-的特性了。

![101](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308171016970.png)

### 删除操作

删除操作相当于插入操作的逆操作。首先还是要先找到目标值，即16这个结点。然后将其删除，此时15节点的子孩子只有一个。不符合特性3了。将16的父节点元素较大值15往下放。同时将15的父节点元素较大值12往下放。此时根节点只有一个元素8，只能有两个子节点。将10和12合并成（0010,0012）。调整指针指向。至此，调整完成，完全符合B-树特性。完成数值16的删除。

![100](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308171019932.png)

## 2 B+树

1. 每个分支结点最多有m棵树和m个关键字
2. 根结点至少两棵子树，其他每个分支结点至少有⌈m/2⌉棵子树
3. 结点的子树个数与关键字个数相等
4. 每个关键字都应该出现在其对应子结点中，且每个结点都按照从小到大的顺序排列
5. 所有终端结点包含全部关键字及指向相应记录的指针。同时终端结点将关键字从小到大顺序排列，并且相终端结点按大小顺序相互链接起来。
6. 同样是是绝对平衡的
   



事实上，B树的查找效率虽然非常优秀，但是它也有一个自身的缺陷。我们都知道，数据库中的数据都是按照记录存放的，每条记录都是由多个数据项组成。因此我们的每条数据记录通常也不会太短，甚至可能非常之长。同样，如果将这些数据记录按照我们的B树进行组织，那么每个结点将存储的内容就是记录本身，B树是将记录本身作为单位存放的。比如我们用一个5阶B树组织在校学生的数据记录，那么我们每个结点都至少存储2条学生记录。这样乍一看好像没什么问题，但是在检索过程中，由于每个结点所占据的存储很大，我们实际的检索速度很难像前面展示的那些B树一样实现快速的检索(前面的树中每个结点的数据记录都是关键字本身，非常小)。

因此我们引入了B+树，B+树的特殊之处在于它将我们的记录的内容放在了叶子结点上，其他分支节点和终端结点只存放关键字。同时所有的结点的关键字都会再次出现在该关键字对应的子结点上即所有的关键字都会出现在终端结点上，这样保证了每个叶子结点上的数据记录都能够有一个关键字与其对应。在这样的调整下我们每个结点只需要存放记录对应关键字，由此相较于B树，在同样大小的结点约束下，我们的B+树的每个结点可以存放更多的关键字，从而大幅降低我们的树高，提升检索速度。


![103](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308171117662.png)



**B+树的插入过程**

      B+树的插入过程与B树相似，都是插到叶节点内。只是在对叶节点分裂时稍有不同，B树分裂叶节点的过程是：将该节点的中间关键字上移至其父亲节点，剩下前半部分的关键字组成新的左叶节点，后半部分是令一个右叶节点，上移的关键字不在叶节点出现了，而B+树分裂叶节点的过程是在上移中间关键字后，还在左叶节点保存这个关键字。

 **B+树的查询过程**

 B+树的查询与B树相似，但是由于B+树只有在叶节点时指针域才保存该关键字的信息，所以必须查询到叶节点才算结束，而B树没有这个限制，和B树相比，B+树的查询比较稳定。**B+树的查找与分块查找类似**.

**B+树的删除过程**
          在B+树中删除关键字是操作B+树中最为复杂的部分，与B树的删除过程相比，B+树不仅要将内节点的关键字删除，而且必须把叶节点的关键字也删除，因此显得更为繁琐。B+树的删除有很多不同的情况，以下列出了具体每种情况和解决过程，并且每种情况的操作过程都不违背B+树的性质。为了保证删除过程没有回溯，因此在递归删除孩子节点的关键字时，需要保证孩子节点的关键字超过半满

- 找到存储有该关键字所在的结点时，由于该结点中关键字个数大于`⌈M/2⌉`，做删除操作不会破坏 B+树，则可以直接删除。

- 找到存储有该关键字所在的结点时，由于该结点中关键字个数大于`⌈M/2⌉`，做删除操作不会破坏 B+树，则可以直接删除。
- 上一种情况基础上，如果其兄弟结点没有多余的关键字，则需要同其兄弟结点**进行合并**。
