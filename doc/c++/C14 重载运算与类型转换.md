# C14 拷贝控制

## 14.1 基本概念

函数名格式为 **operator+要定义的运算符号**

除了重载的函数调用运算符`operator()`外，其他[重载运算符](https://so.csdn.net/so/search?q=重载运算符&spm=1001.2101.3001.7020)不能含有默认实参。

**一般情况下**重载的运算符函数参数数量和运算符作用的运算对象数量**一样多**，且按顺序一一对应。

![82](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308041750718.png)

无法重载**作用于内置类型的运算符**。

可以重载大部分运算符，且只能重载**已经存在的**运算符，**重载的运算符的参数数量，优先级，结合律都和原运算符一样：**

![83](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308041752493.png)

重载运算符时，最好将重载函数定义为与内置类型一致的含义。

![84](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308041811927.png)

## 14.2 输入输出运算符

### 1 重载输出运算符<<

- 通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个ostream对象。
- 第二个形参一般来说是一个常量的引用，该引用是我们想要打印的类型。
- 输出运算符尽量减少格式化操作。
- 输入输出运算符必须是非成员函数，否则它们的左侧运算对象将是我们的类的一个对象。

```c++
ostream &operator<<(ostream& out, const Sales_item& s)
 {
 out << s.isbn << "\t" << s.units_sold << "\t"
 << s.revenue << "\t" << s.avg_price();
 return out;
 } 
```

### 2 重载输入运算符>>

- 通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用。
- 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。

```c++
istream &operator>>(istream& in, Sales_item& s)
 {
 double price;
 in >> s.isbn >> s.units_sold >> price;
 // check that the inputs succeeded
 if (in)
 s.revenue = s.units_sold * price;
 else
 s = Sales_item(); // input failed: reset object to default
state
 return in;
 } 

```

## 14.3 算数和关系运算符

- 通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换，因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。
- 算术运算符得到的新值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果。
- 如果定义了算法运算符，通常会定义一个对应的复合赋值运算符，此时最有效的方式是使用复合赋值运算符来定义算术运算符。

```c++
Sales_item
 operator+(const Sales_item& lhs, const Sales_item& rhs)
 {
 Sales_item ret(lhs); // copy lhs into a local object that we'll return
 ret += rhs; // add in the contents of rhs
 return ret; // return ret by value
 } 
```

### 1 相等运算符

```c++
 bool operator==(const Sales_item &lhs, const Sales_item &rhs)
 {
 // must be made a friend of Sales_item
 return lhs.units_sold == rhs.units_sold &&
 lhs.revenue == rhs.revenue &&
 lhs.same_isbn(rhs);
 }
bool operator!=(const Sales_item &lhs, const Sales_item &rhs)
 {
 return !(lhs == rhs); // != defined in terms of operator==
 } 
```

### 2 关系运算符

![85](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308041843124.png)

## 14.4 赋值运算符

**赋值运算符必须定义为成员函数。**

拷贝赋值运算符和移动赋值运算符都是在**同类型的对象**直接的赋值。除此以外，还可以定义将**不同类型的对象赋予本类型对象**的赋值运算符。

复合赋值运算符不非得是类的成员，不过我们倾向于把包括复合赋值在内的所有赋值运算符都定义在类的内部。

类中的复合赋值运算符要返回其左侧运算对象的引用。

## 14.5 下标运算符

- 表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。
- 下标运算符必须是成员函数。
- 下标运算符通常以所访问元素的引用作为返回值，这样的好处是下标可以出现在赋值运算符的任意一端。
- 最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值（即const 返回类型& operator []（size_t）const{}）。

## 14.6 递增和递减运算符

- 因为递增或者递减运算符恰好改变的是所操作对象的状态，所以建议将其设定为成员函数。
- 前置运算符应该返回递增或递减后对象的引用。
- 为了区分前置版本和后置版本，后置版本接受一个额外的（不被使用）int类型的占位形参。
- 后置运算符应该返回对象递增或递减之前的值，返回的形式是一个值而非引用。
- 可以显式调用后置版本，这种情况下就必须**要自己传递额外参数完成函数重载**了。在用`++/--`时编译器会帮忙干这些事。

## 14.7 成员访问运算符

- 在迭代器类及智能指针类中常常用到解引用运算符（*）和箭头运算符（->）。

- 箭头运算符必须是类的成员，解引用运算符通常也是类的成员。
- 箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。



对箭头运算符返回值的限定：

-  对于形如point->mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator->的类的对象。根据point类型的不同，point->mem分别等价于：

```c++
 	(*point).mem;            //point是一个内置的指针类型
    point.operator->()->mem; //point是类的一个对象
```

**point->mem的执行过程：**

1. 如果point是指针，则我们应用内置的箭头运算符，表达式等价于(*point).mem。
2. 如果point是定义了operator->（）的类的一个对象，则我们使用point.operator->()的结果来获取mem。其中，如果该结果是一个指针，则执行第一步；如果该结果本身含有重载的operator->()，则重复调用当前步骤。
   

## 14.8 函数调用运算符

- 如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更灵活。
- 如果类定义了调用运算符，则该类的对象称作函数对象。函数调用运算符必须是成员函数。

```c++
#include<iostream>
using namespace std;
struct absInt
{
    int operator()(int val) const
    {
        return val < 0 ? -val : val;
    }
};
int main()
{
    int i = -42;
    absInt absObj;
    cout << absObj(i) << endl;
    return 0;
}
```

### 1 lambda是函数对象❤

- 当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象，在lambda表达式产生的类中含有一个重载的函数调用运算符。
- 产生的类只有函数调用运算符一个成员，默认情况下lambda不能改变它所捕获的变量，所以默认情况下由lambda产生的类当中的函数调用运算符是一个const的成员函数。
- 当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引的对象确实存在，因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。
- 通过值捕获的变量要拷贝到lambda中，因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。

### 2 标准库定义的函数对象

标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一执行命名操作的调用运算符。这些类都被定义成模板的形式。这些类型定义在functional头文件中。

![86](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308041856088.png)

### 3 可调用对象与function

**标准库function类型：**

![87](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308041859181.png)

**重载的函数与function：**

- 我们不能直接将重载函数的名字存入function类型的对象中。
- 可以通过存储函数指针或者通过lambda表达式来消除二义性。

## 14.9 重载、类型转换与运算符

### 1 类型转换运算符

- 类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换为其他类型。
- 一般形式：operator type（） const；
- 其中type表示某种类型。类型转换运算符可以面向任意类型（void除外）进行定义，只要该类型能作为函数的返回类型。
- 类型转换运算符没有显式的返回类型，也没有形参，而且必须定义成类的成员函数，类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义为const成员。
- 因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参。
- C++11新标准引入了显示的类型转换运算符：explicit operator type（）const；

```c++
class SmallInt
{
public:
    SmallInt(int i=0):val(i)
    {
        if (i < 0 || i>255)
            throw out_of_range("Bad SmallInt value");
    }
    operator int() const { return val; }
private:
    size_t val;
};
```

### 2 避免二义性类型转换

必须保证**类类型和目标类型间只存在一种转换方式**，否则，代码将具有二义性。

![88](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308041906142.png)

### 3 函数匹配与重载运算符

使用函数时，具有该名字的成员函数和非成员函数不会彼此重载，调用函数的语法形式能区分二者，运算符不能，所以当使用**重载运算符时，重载的候选集要比函数重载大得多**。

![89](https://raw.githubusercontent.com/whyeinstein/ndssl_training_notes/main/img/202308041911541.png)